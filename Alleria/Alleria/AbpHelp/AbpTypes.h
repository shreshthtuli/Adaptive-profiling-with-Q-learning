#ifndef ABP_TYPES_H
#define ABP_TYPES_H

#include <time.h>
#include <stdio.h>

typedef int                INT32;
typedef int                BOOL;
typedef unsigned char      UINT8;
typedef unsigned short     UINT16;
typedef unsigned int       UINT32;
typedef unsigned long long UINT64;
typedef char               CHAR;
typedef CHAR*              PSTR;
typedef const CHAR*        PCSTR;
typedef time_t             TIME;
typedef UINT64             TIME_STAMP;

/// Represents a binary profile handle.
/**
A profile handle uniquely identifies an open profile and must be used to access
any information contained in it.
\sa AbpOpenProfile and  AbpCloseProfile
*/
typedef int                PROFILE_HANDLE;

/// Represents an invalid profile handle.
/**
\sa AbpOpenProfile and  AbpCloseProfile
*/
#define INVALID_PROFILE_HANDLE -1


#define TRUE  1
#define FALSE 0

/// Specifies the type of a section in a binary profile.
typedef enum BINARY_SECTION_TYPE_TAG
{
	/** Specifies an invalid section. */
	BINARY_SECTION_TYPE_INVALID,

	/** 
	Specifies a CpuId section that describes which features that are available on
	a processor package. There is exactly one such section in the Main profile.
	*/
	BINARY_SECTION_TYPE_CPUID,

	/**
	Specifies a Profile section that contains execution traces.
	There can be one or more such section in the same profile.
	*/
	BINARY_SECTION_TYPE_PROFILE,

	/**
	Specifies an LLW section that contains virtual address space state snapshots.
	There is exactly one such section in a profile.
	*/
	BINARY_SECTION_TYPE_LLW,

	/**
	Specifies an Interceptors section that contains execution traces generated by the
	the interception infrastructure. There is exactly one such section in a profile.
	*/
	BINARY_SECTION_TYPE_INTERCEPTORS,

	/**
	Specifies a ProcFam section that describes the process family of the process that
	generated the binary profile currently being used.
	There is exactly one such section in the Main profile.
	*/
	BINARY_SECTION_TYPE_PROCESS_FAMILY,

	/**
	Specifies an Img section that describes the executable binaries that were loaded
	during profiling and used by the app. There can be one or more such section in the same profile.
	*/
	BINARY_SECTION_TYPE_IMAGE_TABLE,

	/**
	Specifies a Func section that describes the functions that were profiled.
	There can be one or more such section in the same profile.
	*/
	BINARY_SECTION_TYPE_FUNC_TABLE

} BINARY_SECTION_TYPE;

/// Specifies the type of an entry in a Profile section of a binary profile.
/**
\sa BINARY_SECTION_TYPE, BINARY_PROFILE_SECTION_ENTRY_MEM, BINARY_PROFILE_SECTION_ENTRY_INS, BINARY_PROFILE_SECTION_ENTRY_PROC, 
\sa BINARY_PROFILE_SECTION_ENTRY_HEADER, AbpGetProfileEntryFirst and AbpGetProfileEntryNext
*/
typedef enum BINARY_PROFILE_SECTION_ENTRY_TYPE_TAG
{
	/**
	Specifies an invalid Profile section entry.
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_INVALID,

	/**
	Specifies an Ins0 entry that describes a profiled instruction.
	\sa BINARY_PROFILE_SECTION_ENTRY_INS
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_INSTRUCTION_0,

	/**
	Specifies an Ins1 entry that describes a profiled instruction.
	\sa BINARY_PROFILE_SECTION_ENTRY_INS
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_INSTRUCTION_1,

	/**
	Specifies an Ins2 entry that describes a profiled instruction.
	\sa BINARY_PROFILE_SECTION_ENTRY_INS
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_INSTRUCTION_2,

	/**
	Specifies an Mem0 entry that describes a profiled memory access.
	\sa BINARY_PROFILE_SECTION_ENTRY_MEM
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_0,

	/**
	Specifies an Mem1 entry that describes a profiled memory access.
	\sa BINARY_PROFILE_SECTION_ENTRY_MEM
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_1,

	/**
	Specifies an Mem2 entry that describes a profiled memory access.
	\sa BINARY_PROFILE_SECTION_ENTRY_MEM
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_2,

	/**
	Specifies an Processor entry that contains thread scheduling information
	\sa BINARY_PROFILE_SECTION_ENTRY_PROC
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_PROCESSOR,

	/**
	Specifies a Syscall entry that contains system call information.
	\sa BINARY_PROFILE_SECTION_ENTRY_SYSCALL
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_SYSCALL_RECORD,

	/**
	Specifies a Branch entry that contains branch information.
	\sa BINARY_PROFILE_SECTION_ENTRY_BRANCH
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_BRANCH_RECORD,

	/**
	Specifies a Header entry that describes the context in which one or more instructions were executed.
	This context includes the OS thread identifier, thread numbers as assigned by Alleria, and other information.
	\sa BINARY_PROFILE_SECTION_ENTRY_HEADER
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_HEADER,

	/**
	Specifies a Memory Region entry that describes a region of memory emitte by the Live Lands Walker.
	\sa BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_REGION
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_REGION

} BINARY_PROFILE_SECTION_ENTRY_TYPE;

/// Specifies the vendor of a processor package.
/**
\sa AbpGetProfileProcessorVendor
*/
typedef enum PROCESSOR_VENDOR_TAG
{
	/**
	Specifies an invalid vendor.
	*/
	PROCESSOR_VENDOR_INVALID,

	/**
	Specifies an unkown vendor.
	\sa PROCESSOR_ARCH
	*/
	PROCESSOR_VENDOR_UNKNOWN,

	/**
	Specifies Intel Corp.
	\sa PROCESSOR_ARCH
	*/
	PROCESSOR_VENDOR_GENUINE_INTEL,

	/**
	Specifies AMD Inc.
	\sa PROCESSOR_ARCH
	*/
	PROCESSOR_VENDOR_AUTHENTIC_AMD

} PROCESSOR_VENDOR;

/// Specifies the architecture of a processor package.
/**
\sa AbpGetProfileProcessorArch
*/
typedef enum PROCESSOR_ARCH_TAG
{
	/**
	Specifies an invalid architecture.
	*/
	PROCESSOR_ARCH_INVALID,

	/**
	Specifies the x86 architecture.
	\sa PROCESSOR_VENDOR
	*/
	PROCESSOR_ARCH_X86,

	/**
	Specifies the x64 architecture.
	\sa PROCESSOR_VENDOR
	*/
	PROCESSOR_ARCH_X64

} PROCESSOR_ARCH;

/// Specifies the type of a binary profile.
/**
\sa AbpGetProfileType
*/
typedef enum BINARY_HEADER_TYPE_TAG
{
	/**
	Specifies an invalid profile.
	*/
	BINARY_HEADER_TYPE_INVALID_PROFILE,

	/**
	Specifies a Main profile which is a profile that contains additional information
	compared to Sub profiles. Typically, CpuId and ProcFam sections can be found only
	in Main profiles.
	*/
	BINARY_HEADER_TYPE_MAIN_PROFILE = 0x01,

	/**
	Specifies a Sub profile which is the profile that typically contains less information
	compared to Main profiles.
	*/
	BINARY_HEADER_TYPE_SUB_PROFILE = 0x02

} BINARY_HEADER_TYPE;

/// Specifies an operating system.
/**
\sa AbpGetProfileOS
*/
typedef enum BINARY_HEADER_OS_TAG
{
	/**
	Specifies an invalid operting system.
	*/
	BINARY_HEADER_OS_INVALID,

	/**
	Specifies any supported version of the Microsoft Windows operating system.
	*/
	BINARY_HEADER_OS_WINDOWS,

	/**
	Specifies any supported version of the Linux operating system.
	*/
	BINARY_HEADER_OS_LINUX

} BINARY_HEADER_OS;

/// Specifies an operating system version.
/**
\sa BINARY_PROFILE_SECTION_ENTRY_SYSCALL and AbpGetProfileOSVersion
*/
typedef enum BINARY_HEADER_OS_VERSION_TAG
{
	/**
	Specifies an invalid operting system version.
	*/
	BINARY_HEADER_OS_VERSION_INVALID,

	/**
	Microsoft Windows 7.
	*/
	BINARY_HEADER_OS_VERSION_WIN_7,

	/**
	Microsoft Windows 7 Service Pack 1.
	*/
	BINARY_HEADER_OS_VERSION_WIN_7_SP1,

	/**
	Microsoft Windows Server 2008 R2.
	*/
	BINARY_HEADER_OS_VERSION_WIN_SERVER_2008_R2,

	/**
	Microsoft Windows 8.
	*/
	BINARY_HEADER_OS_VERSION_WIN_8,

	/**
	Microsoft Windows Server 2012.
	*/
	BINARY_HEADER_OS_VERSION_WIN_SERVER_2012,

	/**
	Microsoft Windows 8.1.
	*/
	BINARY_HEADER_OS_VERSION_WIN_8_1,

	/**
	Microsoft Windows Server 2012 R2.
	*/
	BINARY_HEADER_OS_VERSION_WIN_SERVER_2012_R2,

	/**
	Microsoft Windows 10.
	*/
	BINARY_HEADER_OS_VERSION_WIN_10,

	/**
	Microsoft Windows Server 2016.
	*/
	BINARY_HEADER_OS_VERSION_WIN_SERVER_2016
} BINARY_HEADER_OS_VERSION;

/// Represents an entry in the section directory table of a binary profile.
/**
\sa AbpGetProfileSectionDirectorySize and AbpGetProfileSectionDirectoryEntry
*/
typedef struct SECTION_DIRECTORY_ENTRY_TAG
{
	/**
	Do not use this field.
	*/
	UINT64 reserved;

	/**
	Specifies the type of the section pointed to by the section directory entry.
	\sa BINARY_SECTION_TYPE
	*/
	BINARY_SECTION_TYPE type;

} SECTION_DIRECTORY_ENTRY, *PSECTION_DIRECTORY_ENTRY;


/// Represents an entry in a CpuId section. Each entry contains some information about a processor package.
/**
\sa BINARY_SECTION_TYPE, AbpGetCpuInfo, AbpCpuId and AbpGetCpuCount
*/
typedef struct CPUID_INFO_TAG
{
	/**
	Stores the leaf (Intel) or the function id (AMD) that was passed to the CPUID instruction.
	*/
	UINT32 EAX;

	/**
	Stores the subleaf (Intel) or the subfunction id (AMD) that was passed to the CPUID instruction.
	*/
	UINT32 ECX;

	/**
	Stores the supported features and CPU information bitmap that was returned from the CPUID instruction
	in the EAX register.
	*/
	UINT32 cpuInfo1;

	/**
	Stores the supported features and CPU information bitmap that was returned from the CPUID instruction
	in the EBX register.
	*/
	UINT32 cpuInfo2;

	/**
	Stores the supported features and CPU information bitmap that was returned from the CPUID instruction
	in the ECX register.
	*/
	UINT32 cpuInfo3;

	/**
	Stores the supported features and CPU information bitmap that was returned from the CPUID instruction
	in the EDX register.
	*/
	UINT32 cpuInfo4;

} CPUID_INFO, *PCPUID_INFO;

/// Represents an entry in a ProcFam section. Each entry represents a process.
/**
\sa BINARY_SECTION_TYPE, AbpGetProcessFamily, AbpGetProcessWithNumber and AbpGetProcessWithId
*/
typedef struct BINARY_PROCESS_FAMILY_ENTRY_TAG
{
	/**
	Stores the process number as assigned by Alleria.
	Process numbers are unique within a process tree.
	*/
	UINT32  pn;

	/**
	Stores the process ID as assigned by the operating system.
	Process IDs may not be unique within a process tree.
	*/
	UINT32  pId;

	/**
	Stores the time at which the process were created, approximately.
	*/
	TIME t;

} BINARY_PROCESS_FAMILY_ENTRY, *PBINARY_PROCESS_FAMILY_ENTRY;

/// Represents an entry in a Profile section.
/**
\sa BINARY_SECTION_TYPE, AbpGetProfileEntryFirst and AbpGetProfileEntryNext
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_GENERIC_TAG
{
	/**
	Specifies the type of the entry that this structure represents.
	\sa BINARY_PROFILE_SECTION_ENTRY_TYPE
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE type;

	/**
	Do not use this field.
	*/
	UINT32 reserved;

	/**
	Stores a pointer to a Profile section entry of the type specified in the \a type field.
	If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_INVALID, entry does not point to a valid
	\a entry object and should not be accessed. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_HEADER, 
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_HEADER. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_INSTRUCTION_X
	where X is a number, \a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_INS. If \a type is
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_X where X is a number, \a entry points to an object of type 
	BINARY_PROFILE_SECTION_ENTRY_MEM. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_PROCESSOR, \a entry
	points to an object of type BINARY_PROFILE_SECTION_ENTRY_PROC. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_SYSCALL_RECORD,
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_SYSCALL. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_BRANCH_RECORD,
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_BRANCH.
	\sa BINARY_PROFILE_SECTION_ENTRY_TYPE, BINARY_PROFILE_SECTION_ENTRY_HEADER, BINARY_PROFILE_SECTION_ENTRY_INS, BINARY_PROFILE_SECTION_ENTRY_MEM,
	\sa BINARY_PROFILE_SECTION_ENTRY_PROC, BINARY_PROFILE_SECTION_ENTRY_SYSCALL and BINARY_PROFILE_SECTION_ENTRY_BRANCH
	*/
	void *entry;

} BINARY_PROFILE_SECTION_GENERIC, *PBINARY_PROFILE_SECTION_GENERIC;

/// Represents a trace in a Profile section.
/**
\sa BINARY_SECTION_TYPE, AbpGetProfileTraceFirst and AbpGetProfileTraceNext
*/
typedef struct BINARY_PROFILE_SECTION_TRACE_GENERIC_TAG
{
	/**
	Specifies the type of the entry that this structure represents.
	\sa BINARY_PROFILE_SECTION_ENTRY_TYPE
	*/
	BINARY_PROFILE_SECTION_ENTRY_TYPE type;

	/**
	Do not use this field.
	*/
	UINT32 reserved;

	/**
	Stores a pointer to a Profile section entry of the type specified in the \a type field.
	If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_INVALID, entry does not point to a valid
	\a entry object and should not be accessed. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_HEADER,
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_HEADER. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_INSTRUCTION_X
	where X is a number, \a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_INS. If \a type is
	BINARY_PROFILE_SECTION_ENTRY_TYPE_MEMORY_X where X is a number, \a entry points to an object of type
	BINARY_PROFILE_SECTION_ENTRY_MEM. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_PROCESSOR, \a entry
	points to an object of type BINARY_PROFILE_SECTION_ENTRY_PROC. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_SYSCALL_RECORD,
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_SYSCALL. If \a type is BINARY_PROFILE_SECTION_ENTRY_TYPE_BRANCH_RECORD,
	\a entry points to an object of type BINARY_PROFILE_SECTION_ENTRY_BRANCH.
	\sa BINARY_PROFILE_SECTION_ENTRY_TYPE, BINARY_PROFILE_SECTION_ENTRY_HEADER, BINARY_PROFILE_SECTION_ENTRY_INS, BINARY_PROFILE_SECTION_ENTRY_MEM,
	\sa BINARY_PROFILE_SECTION_ENTRY_PROC, BINARY_PROFILE_SECTION_ENTRY_SYSCALL and BINARY_PROFILE_SECTION_ENTRY_BRANCH
	*/
	void *entry;

	/*
	Stores the number of elements in the \a nodes array.
	*/
	UINT64 nodeCount;

	/*
	An array of objects of type BINARY_PROFILE_SECTION_TRACE_GENERIC.
	Each element of the array has a semantic relation to its parent BINARY_PROFILE_SECTION_TRACE_GENERIC.
	The size of the array is stored in \a nodeCount.
	*/
	struct BINARY_PROFILE_SECTION_TRACE_GENERIC_TAG *nodes;

} BINARY_PROFILE_SECTION_TRACE_GENERIC, *PBINARY_PROFILE_SECTION_TRACE_GENERIC, **PPBINARY_PROFILE_SECTION_TRACE_GENERIC;

/// Represents a Header entry in a Profile section.
/**
\sa BINARY_PROFILE_SECTION_GENERIC and BINARY_SECTION_TYPE
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_HEADER_TAG
{
	/**
	Do not use this field.
	*/
	UINT64 reserved;

	/**
	specifies the thread number as assigned by Alleria of the thread in which the instructions
	that follow this entry in the Profile section were executed.
	*/
	UINT64 tn;

	/**
	specifies the thread ID as assigned by the operating system of the thread in which the instructions
	that follow this entry in the Profile section were executed.
	*/
	UINT32 ostid;

	/**
	specifies an index in the section directory of the entry that points to a Func section in which the instructions
	that follow this entry in the Profile section were executed.
	\sa BINARY_SECTION_TYPE
	*/
	UINT32 funcIndex;

} BINARY_PROFILE_SECTION_ENTRY_HEADER, *PBINARY_PROFILE_SECTION_ENTRY_HEADER;

/// Represents a Proc entry in a Profile section.
/**
Objects of this type are only valid when AbpDoesProfileContainSchedulingInfo() returns TRUE.
\sa BINARY_PROFILE_SECTION_GENERIC, BINARY_SECTION_TYPE and AbpDoesProfileContainSchedulingInfo
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_PROC_TAG
{
	/**
	Do not use this field.
	*/
	UINT64 reserved;

	/**
	Stores the index of a CpuId entry in the CpuId section of the Main profile.
	*/
	UINT32 package;

	/**
	Stores the index of the hardware thread in the process package that executed the instructions
	that follow this entry in the Profile section were executed.
	*/
	UINT32 number;

} BINARY_PROFILE_SECTION_ENTRY_PROC, *PBINARY_PROFILE_SECTION_ENTRY_PROC;

/// Represents a Ins0, Ins1 or Ins2 entry in a Profile section.
/**
An InsX entry represents an instruction that was executed.
\sa BINARY_PROFILE_SECTION_GENERIC, BINARY_SECTION_TYPE and AbpDoesProfileContainIns
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_INS_TAG
{
	/**
	Do not use this field.
	*/
	UINT64 reserved;

	/**
	Stores an index in a Func Section of the function to which the instruction belongs.
	This is only valid if the type of the entry is either Ins0 or Ins1.
	*/
	UINT32 routineId;

	/**
	Stores the virtual address of the instruction. This field is valid for all entry types but only when 
	AbpGetProfileVirtualAddrSize returns a value larger than zero.
	\sa AbpGetProfileVirtualAddrSize
	*/
	UINT64 vAddr;

	/**
	Stores the physical address of the instruction. This field is valid for all entry types but only when 
	AbpGetProfilePhysicalAddrSize returns a value larger than zero. Also the physical address may be zero
	if Alleria was not able to capture it.
	\sa AbpGetProfilePhysicalAddrSize
	*/
	UINT64 pAddr;

	/**
	Stores a timestamp specifying the time at which the instruction was executed
	with respect to all other instructions in the same process. The resolution of
	this timestamp is at most 100 ns. The order of execution indicated by timestamps is deterministic within a software thread.
	However, it's not deteriministic accross threads. This is only valid if the type of the entry is Ins0.
	The value of this field is always larger then zero and it's relative to the app startup timestamp.
	\sa AbpGetProfileStartingTime and AbpGetInstructionTimestampFrequency
	*/
	TIME_STAMP timestamp;

	/**
	Stores a pointer to a sequence of bytes representing the instruction according in the x86 encoding.
	This pointer is only valid if AbpDoesProfileContainIns() returns TRUE. Either way, this field may contain NULL.
	This happens the instruction was removed from memory before the profiler records it.
	\sa AbpDoesProfileContainIns
	*/
	UINT8 *insBytes;

} BINARY_PROFILE_SECTION_ENTRY_INS, *PBINARY_PROFILE_SECTION_ENTRY_INS;

/// Specifies the type of a memory access.
/**
\sa BINARY_PROFILE_SECTION_ENTRY_MEM and BINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO
*/
typedef enum MEM_OP_TYPE_TAG
{
	/**
	Specifies a Store or Write memory access.
	*/
	MEM_OP_TYPE_STORE,

	/**
	Specifies a Load or Read memory access.
	*/
	MEM_OP_TYPE_LOAD,

	/**
	Specifies multiple memory accesses.
	*/
	MEM_OP_TYPE_MULTI,

} MEM_OP_TYPE;

/// Represents a collection of memory accesses performed by the same instruction.
/**
BINARY_PROFILE_SECTION_ENTRY_MEM.info points to an object of this type if the entry is of type Mem0 and
the type of the memory access is MEM_OP_TYPE_MULTI.
\sa MEM_OP_TYPE and BINARY_PROFILE_SECTION_ENTRY_MEM
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO_TAG
{
	/**
	Stores the number of memory accesses represented by the object.
	*/
	UINT32            numberOfMemops;

	/**
	An array of objects, each representing a single memory access.
	The size of the array is given by \a numberOfMemops.
	*/
	struct MEMORY_ACCESS
	{
		/**
		Stores the virtual address of the memory access. This field is valid when
		AbpGetProfileVirtualAddrSize returns a value larger than zero.
		\sa AbpGetProfileVirtualAddrSize
		*/
		UINT64        vAddr;

		/**
		Stores the physical address of the memory access. This field is valid when
		AbpGetProfilePhysicalAddrSize returns a value larger than zero. The physical address may be zero
		if Alleria was not able to capture it.
		\sa AbpGetProfilePhysicalAddrSize
		*/
		UINT64        pAddr;

		/**
		Holds a pointer to the sequence of bytes that were read or written.
		This field is valid for the Mem0 entry type. This field is NULL if the instruction that performed the memory access 
		did not execute successfully. Even in that case, all other fields are still valid.
		*/
		UINT8         *value;

		/**
		Specifies the type of the memory access represented by the object.
		The type can be either MEM_OP_TYPE_LOAD or MEM_OP_TYPE_STORE.
		\sa MEM_OP_TYPE
		*/
		MEM_OP_TYPE   memopType;

		/**
		Stores the number of bytes that were read or written.
		*/
		UINT32        bytesAccessed;

		/**
		If the value of this field is TRUE, the memory access has been been performed.
		Otherwise, it has not been performed.
		*/
		BOOL          maskOn;

	} *accesses;

} BINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO, *PBINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO;

/// Represents a Mem0, Mem1 or Mem2 entry in a Profile section.
/**
An MemX entry represents one or more memory accesses issued by a single instruction.
\sa BINARY_PROFILE_SECTION_GENERIC, BINARY_SECTION_TYPE, MEM_OP_TYPE and BINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_MEM_TAG
{
	/**
	Do not use this field.
	*/
	UINT64        reserved;

	/**
	Specifies the type of all memory accesses represented by the object.
	If the type is MEM_OP_TYPE_LOAD or MEM_OP_TYPE_STORE, the info field points
	to the sequence of bytes that were read or written. If the type is 
	MEM_OP_TYPE_MULTI, the info field points
	to either a BINARY_PROFILE_SECTION_ENTRY_MEM_EXTENDED_INFO object depending on
	the value in type field of associated BINARY_PROFILE_SECTION_GENERIC object.
	\sa MEM_OP_TYPE, BINARY_PROFILE_SECTION_ENTRY_TYPE and BINARY_PROFILE_SECTION_GENERIC
	*/
	MEM_OP_TYPE   memopType;

	/**
	If the memory access type is MEM_OP_TYPE_LOAD or MEM_OP_TYPE_STORE, this field stores
	the size of the value accessed. Otherwise, it stores the total number of bytes accessed.
	This field is valid for Mem0 and Mem1 entries type only.
	\sa MEM_OP_TYPE, BINARY_PROFILE_SECTION_ENTRY_TYPE and BINARY_PROFILE_SECTION_GENERIC
	*/
	UINT32        size;

	/**
	Stores the base virtual address of the memory access(es). This field is valid for Mem0 and Mem1 entry types but only when
	AbpGetProfileVirtualAddrSize returns a value larger than zero.
	\sa AbpGetProfileVirtualAddrSize, BINARY_PROFILE_SECTION_ENTRY_TYPE and BINARY_PROFILE_SECTION_GENERIC
	*/
	UINT64        vAddr;

	/**
	Stores the base physical address of memory access(es). This field is valid for Mem0 and Mem1 entry types but only when
	AbpGetProfilePhysicalAddrSize returns a value larger than zero. The physical address may be zero
	if Alleria was not able to capture it.
	\sa AbpGetProfilePhysicalAddrSize, BINARY_PROFILE_SECTION_ENTRY_TYPE and BINARY_PROFILE_SECTION_GENERIC
	*/
	UINT64        pAddr;

	/**
	Points to a structure that contains additional information about the memory access. The meaning
	of this structure depends on the memory access type. This field is valid for the Mem0 entry type.
	It's also valid for Mem1 entries but only when the access type is MEM_OP_TYPE_MULTI.
	For Mem0 entries whose access types are either MEM_OP_TYPE_STORE or MEM_OP_TYPE_LOAD,
	this field is NULL if the instruction that performed the memory access did not execute successfully.
	Even in that case, all other fields are still valid.
	\sa MEM_OP_TYPE, BINARY_PROFILE_SECTION_ENTRY_TYPE and BINARY_PROFILE_SECTION_GENERIC
	*/
	UINT8         *info;

} BINARY_PROFILE_SECTION_ENTRY_MEM, *PBINARY_PROFILE_SECTION_ENTRY_MEM;

/// Represents a Branch entry in a Profile section.
/**
An Branch entry contains information about a conditional or unconditional branch instruction.
\sa BINARY_PROFILE_SECTION_GENERIC and BINARY_SECTION_TYPE
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_BRANCH_TAG
{
	/**
	Do not use this field.
	*/
	UINT64        reserved;

	/**
	TRUE if the branch was taken, and FALSE otherwise.
	*/
	BOOL taken;

	/**
	The virtual address of the target instruction of the branch.
	*/
	UINT64 vTarget;

	/**
	The physical address of the target instruction of the branch.
	*/
	UINT64 pTarget;

} BINARY_PROFILE_SECTION_ENTRY_BRANCH, *PBINARY_PROFILE_SECTION_ENTRY_BRANCH;

/// Represents a Syscall entry in a Profile section.
/**
An Syscall entry contains information about a system call instruction instruction including interrupt-based system calls.
\sa BINARY_PROFILE_SECTION_GENERIC and BINARY_SECTION_TYPE
*/
typedef struct BINARY_PROFILE_SECTION_ENTRY_SYSCALL_TAG
{
	/**
	Do not use this field.
	*/
	UINT64        reserved;

	/**
	The system call error number.
	*/
	UINT64 err;

	/**
	The system call number.
	\sa BINARY_HEADER_OS and AbpGetProfileOS
	*/
	UINT64 num;

	/**
	The system call return value.
	*/
	UINT64 retVal;

	/**
	The system call argument 0. This argument may not be valid depending on the system call.
	*/
	UINT64 arg0;

	/**
	The system call argument 1. This argument may not be valid depending on the system call.
	*/
	UINT64 arg1;

	/**
	The system call argument 2. This argument may not be valid depending on the system call.
	*/
	UINT64 arg2;

	/**
	The system call argument 3. This argument may not be valid depending on the system call.
	*/
	UINT64 arg3;

	/**
	The system call argument 4. This argument may not be valid depending on the system call.
	*/
	UINT64 arg4;

	/**
	The system call argument 5. This argument may not be valid depending on the system call.
	*/
	UINT64 arg5;

	/**
	The system call argument 6. This argument may not be valid depending on the system call.
	*/
	UINT64 arg6;

	/**
	The system call argument 7. This argument may not be valid depending on the system call.
	*/
	UINT64 arg7;

	/**
	The system call argument 8. This argument may not be valid depending on the system call.
	*/
	UINT64 arg8;

	/**
	The system call argument 9. This argument may not be valid depending on the system call.
	*/
	UINT64 arg9;

	/**
	The system call argument 10. This argument may not be valid depending on the system call.
	*/
	UINT64 arg10;

	/**
	The system call argument 11. This argument may not be valid depending on the system call.
	*/
	UINT64 arg11;

	/**
	The system call argument 12. This argument may not be valid depending on the system call.
	*/
	UINT64 arg12;

	/**
	The system call argument 13. This argument may not be valid depending on the system call.
	*/
	UINT64 arg13;

	/**
	The system call argument 14. This argument may not be valid depending on the system call.
	*/
	UINT64 arg14;

	/**
	The system call argument 15. This argument may not be valid depending on the system call.
	*/
	UINT64 arg15;

	/**
	TRUE means that \a err and \a retVal are valid.
	FALSE means that  \a err and \a retVal are invalid because
	Alleria were not able to capture them.
	*/
	BOOL errRetRecorded;

} BINARY_PROFILE_SECTION_ENTRY_SYSCALL, *PBINARY_PROFILE_SECTION_ENTRY_SYSCALL;

typedef struct BINARY_LLW_SECTION_ENTRY_BLOCK_TAG
{
	UINT64 vAddr;
	UINT32 protectionFlags;
	UINT32 storageFlags;

} BINARY_LLW_SECTION_ENTRY_BLOCK, *PBINARY_LLW_SECTION_ENTRY_BLOCK;

typedef struct BINARY_LLW_SECTION_ENTRY_REGION_TAG
{
	UINT64 vAddr;
	UINT32 protectionFlags;
	UINT32 storageFlags;
	UINT16 usageType;
	UINT16 user;
	PCSTR userId;
	UINT64 blockCount;
	PBINARY_LLW_SECTION_ENTRY_BLOCK blocks;

} BINARY_LLW_SECTION_ENTRY_REGION, *PBINARY_LLW_SECTION_ENTRY_REGION;

typedef struct BINARY_LLW_SECTION_ENTRY_SNAPSHOT_TAG
{
	/**
	Do not use this field.
	*/
	UINT32 reserved1;

	/**
	Do not use this field.
	*/
	UINT64 reserved2;

	TIME_STAMP ts;
	UINT64 memoryPin;
	UINT64 regionCount;

	PBINARY_LLW_SECTION_ENTRY_REGION regions;

} BINARY_LLW_SECTION_ENTRY_SNAPSHOT, *PBINARY_LLW_SECTION_ENTRY_SNAPSHOT;

typedef enum ABP_ERROR_TAG
{
	ABP_ERROR_SUCCESS
} ABP_ERROR;

#endif /* ABP_TYPES_H */