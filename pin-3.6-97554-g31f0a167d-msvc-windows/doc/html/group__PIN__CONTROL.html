<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Controlling and Initializing</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Controlling and Initializing</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCALL__APPLICATION__FUNCTION__PARAM.html">CALL_APPLICATION_FUNCTION_PARAM</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__PIN__CONTROL.html#g8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g07c2d0d5846d67bdcb924e0f0aae75fc">LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#g3c6833a027db42b5d528a0c65cefbc07">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gdfef9e89968c6491114d7ceae51ab61b">LEVEL_PINCLIENT::PIN_CONFIGURATION_INFO</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g1fcf0ef617d803b3264c6136f873c726">LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g691ef173936cecf038159eea5c1f72d1">LEVEL_PINCLIENT::DETACH_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g698d5e8e76d0e196c274bec28e4570cd">LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g79fa77e14c506144fd7f053bea02f69a">LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g010d2c9c0916f7d449cca75b6049378b">LEVEL_PINCLIENT::ATTACH_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g699d6580c1bb0d575c452f6571d67ef6">LEVEL_PINCLIENT::APPLICATION_START_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g27bb61b168e41345426b3057dd4122ff">LEVEL_PINCLIENT::PREPARE_FOR_FINI_CALLBACK</a> (VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g3311decfd798a6b4717705a0d842936e">LEVEL_PINCLIENT::FINI_CALLBACK</a> (INT32 code, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g0372373ea88181877e8ce7940b50a48e">LEVEL_PINCLIENT::FETCH_CALLBACK</a> (void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4e3a72a2897522238554d8e24e712f49">LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK</a> (size_t size, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL *)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g1f3211dd5ce1c837e967ec9baa3e86fc">LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK</a> (PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g805a0df42777e7c3fed4293b957e9517">LEVEL_PINCLIENT::FORK_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g3d6ca92519234f558438455528d98268">LEVEL_PINCLIENT::THREAD_START_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6f5b81f46ccb76dd76f8f34c5bdb6ef3">LEVEL_PINCLIENT::THREAD_FINI_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gee4246ef0764b57c3d4cf16cfd386530">LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#g8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *to, INT32 info, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef BOOL(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gd208f697a16773fe82ac33ee8aec67be">LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g989519cc87af23252e98d16012353ec3">LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK</a> (IMG img, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g139152abe353fdff0216a5519d261c73">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg139152abe353fdff0216a5519d261c73f44e4b240fa01ca6ed3a64acf6022ce4">LEVEL_PINCLIENT::NO_SYMBOLS</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg139152abe353fdff0216a5519d261c733486158cb738b76b7385310ec8f5b671">LEVEL_PINCLIENT::EXPORT_SYMBOLS</a> =  (1&lt;&lt;0), 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg139152abe353fdff0216a5519d261c7325bfc332ecb53ef24ee4ff743d09bde1">LEVEL_PINCLIENT::DEBUG_SYMBOLS</a> =  (1&lt;&lt;1), 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg139152abe353fdff0216a5519d261c73a07edbcaef24a5dbbe880f20916bd74e">LEVEL_PINCLIENT::IFUNC_SYMBOLS</a> =  (1&lt;&lt;2), 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg139152abe353fdff0216a5519d261c73172580d6ba02ac51ce4d3140bdafec07">LEVEL_PINCLIENT::DEBUG_OR_EXPORT_SYMBOLS</a> =  (DEBUG_SYMBOLS | EXPORT_SYMBOLS)
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g0244f9b4e34e4eed7d483fa6ec7b70f0">LEVEL_PINCLIENT::SMC_ENABLE_DISABLE_TYPE</a> { <br>
&nbsp;&nbsp;<b>SMC_ENABLE</b>, 
<br>
&nbsp;&nbsp;<b>SMC_DISABLE</b>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gb459bf0034704bf1aa7fa7e192b7dc08">LEVEL_PINCLIENT::FPOINT</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb459bf0034704bf1aa7fa7e192b7dc08d25e85d29c19e7e0c5a9a768191bbcd7">LEVEL_PINCLIENT::FPOINT_BEFORE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb459bf0034704bf1aa7fa7e192b7dc08e95eedd3db4447dda41b3fe76c7013c6">LEVEL_PINCLIENT::FPOINT_AFTER_IN_PARENT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb459bf0034704bf1aa7fa7e192b7dc08b97d0822ccc4bd553feab25fc85412fc">LEVEL_PINCLIENT::FPOINT_AFTER_IN_CHILD</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gf9a18d894714ae57264a2302638fc4b3">LEVEL_PINCLIENT::ATTACH_STATUS</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggf9a18d894714ae57264a2302638fc4b3b479d68822d4264f3ad10880a5b21a3d">LEVEL_PINCLIENT::ATTACH_INITIATED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggf9a18d894714ae57264a2302638fc4b314afa31e2dadab79279e93630e18f671">LEVEL_PINCLIENT::ATTACH_FAILED_DETACH</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e712c798df1d0e94022f6382a4c8239e">CONTEXT_CHANGE_REASON_FATALSIGNAL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a843b8b032e969e0e5d14a3ed7385f29db">CONTEXT_CHANGE_REASON_SIGNAL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a87e8b6943c9aa3a85b0a9cd23bc738dd9">CONTEXT_CHANGE_REASON_SIGRETURN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a8641c250ce491d66cc19f1205160dc279">CONTEXT_CHANGE_REASON_APC</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e4c034a98f8eba91b2f8ac5b2543492b">CONTEXT_CHANGE_REASON_EXCEPTION</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8e4e6511a0e09fdc5ec7d6dbf395b3a85b48097c22e4fcfdf12650129f364b50">CONTEXT_CHANGE_REASON_CALLBACK</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8c5c16fb133375efa3a27d3a3900c60332e365f541f4ea48f730a030185558cd">EHR_HANDLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8c5c16fb133375efa3a27d3a3900c603b394692e0b4ad2fda77e7597c75c9599">EHR_UNHANDLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg8c5c16fb133375efa3a27d3a3900c6031950501612b017bd8db1634f7dc8bf8f">EHR_CONTINUE_SEARCH</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4e114852e46d5d839d6e71e242709777">PIN_CALLBACK_TYPE</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg4e114852e46d5d839d6e71e242709777f6f04d87615566deb3bd49ec1e3468ef">PIN_CALLBACK_TYPE_NONE</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg4e114852e46d5d839d6e71e242709777e9e0416b9e54e38bc1cf69956f81bc2c">PIN_CALLBACK_TYPE_SYSCALL</a> =  1
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">LEVEL_PINCLIENT::PIN_InitSymbols</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc133406ab660e13f67dd64f27cdf67c6">LEVEL_PINCLIENT::PIN_InitSymbolsAlt</a> (SYMBOL_INFO_MODE mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g5f4e19c43f3de21d382c3c4e2442d961">LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction</a> (FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g60adbdd03078851f0e2611ab06e17c19">LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler</a> (INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">LEVEL_PINCLIENT::PIN_TryStart</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">LEVEL_PINCLIENT::PIN_TryEnd</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g294137f03b1d950d0f1f95968979b490">LEVEL_PINCLIENT::PIN_IsProbeMode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gbb4b02d78ee780c3b70e86a86ff798cd">LEVEL_PINCLIENT::PIN_IsAttaching</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g389d27155d820029712f396a2a824370">LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion</a> (ADDRINT addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g163322863f36bbbeef986c94d319eef0">LEVEL_PINCLIENT::PIN_InsertCallProbed</a> (ADDRINT addr, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gdf5abd51ee9b1d599c539a9e2784e9ef">LEVEL_PINCLIENT::PIN_LockClient</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6239dd852b5236f75413209aceb7a79">LEVEL_PINCLIENT::PIN_UnlockClient</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">LEVEL_PINCLIENT::PIN_CallApplicationFunction</a> (const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, <a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__PROTO__API.html#gcfd9f3c8dc22310ce9b9152e8c61b17c">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr, <a class="el" href="structCALL__APPLICATION__FUNCTION__PARAM.html">CALL_APPLICATION_FUNCTION_PARAM</a> *param,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc167b8d28d255e53a0ac1f6e9edcd3ec">LEVEL_PINCLIENT::PIN_AddFiniFunction</a> (FINI_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g3ca849f6b9c098afb7769e0845cc52c1">LEVEL_PINCLIENT::PIN_AddPrepareForFiniFunction</a> (PREPARE_FOR_FINI_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g50e51f92c7ea2b6d8b271ecf71a7db65">LEVEL_PINCLIENT::PIN_AddFetchFunction</a> (FETCH_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g29ad6213c90cfee4a67640798c0c2501">LEVEL_PINCLIENT::PIN_FetchCode</a> (void *copyBuf, const VOID *address, size_t maxSize, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g897b98855a1853146f9d291687f41946">LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction</a> (OUT_OF_MEMORY_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6d9a4cd860d8168ce1dab07da404752e">LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction</a> (MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">MEMORY_ADDR_TRANS_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8852a4e2eb765b1356069037bdf05f83">LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gfc04e55a26e3b74cdebb8c6a1bf5503b">LEVEL_PINCLIENT::PIN_AddDetachFunction</a> (DETACH_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gfd8d7788f12ec84f1c81074851ff716d">LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed</a> (DETACH_PROBED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g93431bb0680a22395327ac7d8bb0c14c">LEVEL_PINCLIENT::PIN_AddThreadStartFunction</a> (THREAD_START_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6bdae30ea6adc711a3ae04aed47bc222">LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction</a> (THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g697a1abfcdcc139915c008190aba9dcb">LEVEL_PINCLIENT::PIN_AddThreadAttachFunction</a> (THREAD_ATTACH_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ge579102abbf9c663827c82b867db63ad">LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction</a> (THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7f157496433d50573d2f025beca83e5a">LEVEL_PINCLIENT::PIN_AddThreadDetachFunction</a> (THREAD_DETACH_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4516c650e020cd12a5425b08588d2ae2">LEVEL_PINCLIENT::PIN_AddApplicationStartFunction</a> (APPLICATION_START_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ge79d468cc5e19b450603f07f3397203d">LEVEL_PINCLIENT::PIN_AddThreadFiniFunction</a> (THREAD_FINI_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g786fd61c9be3c42a1a6deefc71dffadf">LEVEL_PINCLIENT::PIN_AddContextChangeFunction</a> (CONTEXT_CHANGE_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g240de32335a0aca3ceee37ad96b1dd12">LEVEL_PINCLIENT::PIN_InterceptSignal</a> (INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc7795f34b4a267644e4d10b288c38d96">LEVEL_PINCLIENT::PIN_UnblockSignal</a> (INT32 sig, BOOL enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gec69b96ad1f34e000f56a06abfd1311b">LEVEL_PINCLIENT::PIN_SetSmcSupport</a> (SMC_ENABLE_DISABLE_TYPE enable_disable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g234255869a62bce07edda25d34ffd5b7">LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction</a> (PROBES_INSERTED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CALLBACK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7282900fb6160031936d8b63fecc4e21">LEVEL_PINCLIENT::PIN_AddForkFunction</a> (FPOINT point, FORK_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7f5784c3b9431086f3b5b750912ca0c2">LEVEL_PINCLIENT::PIN_RemoveInstrumentation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gf896499ed7402ef4e34baaa64626e0bd">LEVEL_PINCLIENT::PIN_RemoveInstrumentationInRange</a> (ADDRINT start, ADDRINT end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gfc1635c2b2550236a66dcba25f9cc8a7">LEVEL_PINCLIENT::PIN_RemoveFiniFunctions</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">LEVEL_PINCLIENT::PIN_Detach</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ATTACH_STATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4940c04f3fe39a87090c6872b9ba7e5a">LEVEL_PINCLIENT::PIN_Attach</a> (ATTACH_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g634584cd69b124a7edd58655010e295f">LEVEL_PINCLIENT::PIN_DetachProbed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ATTACH_STATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g5630fbebba55f0b78adb96adccc8daf8">LEVEL_PINCLIENT::PIN_AttachProbed</a> (ATTACH_PROBED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PIN_CONFIGURATION_INFO&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gbf3035f1cd239935bb4b9d45b39be266">LEVEL_PINCLIENT::PIN_CreateDefaultConfigurationInfo</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g48dd43d356a2b768c7c0d3cbc4e1fee6">LEVEL_PINCLIENT::PIN_SetAllowedConcurrentCallbacks</a> (PIN_CONFIGURATION_INFO options, <a class="el" href="group__PIN__CONTROL.html#g4e114852e46d5d839d6e71e242709777">PIN_CALLBACK_TYPE</a> callbackType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">LEVEL_PINCLIENT::PIN_StartProgram</a> (PIN_CONFIGURATION_INFO options=PIN_CreateDefaultConfigurationInfo())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">LEVEL_PINCLIENT::PIN_StartProgramProbed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">LEVEL_PINCLIENT::PIN_Init</a> (INT32 argc, CHAR **argv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">CHAR *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gb047eba18942e83814934eda278de607">LEVEL_PINCLIENT::PIN_VmFullPath</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const CHAR *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc266390e4b69a624a88adcda64ac86c8">LEVEL_PINCLIENT::PIN_ToolFullPath</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g98669d2f5629027689d60bd852ffa0eb">LEVEL_PINCLIENT::PIN_SafeCopy</a> (VOID *dst, const VOID *src, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g271a2d60a060ddd0c13d6599afe8c0e2">LEVEL_PINCLIENT::PIN_SafeCopyEx</a> (VOID *dst, const VOID *src, size_t size, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc671358905f7d4dac7d544b6048e3ee3">LEVEL_PINCLIENT::PIN_IsActionPending</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4494aa98db78e24a10caec922404200e">LEVEL_PINCLIENT::PIN_GetInitialThreadCount</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g97c4af33bb0a330a0967c80c61fcd1c4">LEVEL_PINCLIENT::PIN_CheckReadAccess</a> (VOID *addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gb1c7bfe02dcbcc4415ef03a7267a1b11">LEVEL_PINCLIENT::PIN_CheckWriteAccess</a> (VOID *addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g0df38f14792706f4377486473c0bb382">LEVEL_PINCLIENT::PIN_GetAuxVectorValue</a> (ADDRINT type, bool *found)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This group of functions is used to initialize Pin, start the application, and a call backs for events like application exit. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g699d6580c1bb0d575c452f6571d67ef6"></a><!-- doxytag: member="LEVEL_PINCLIENT::APPLICATION_START_CALLBACK" ref="g699d6580c1bb0d575c452f6571d67ef6" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g699d6580c1bb0d575c452f6571d67ef6">LEVEL_PINCLIENT::APPLICATION_START_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when pin initialization is finished.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g010d2c9c0916f7d449cca75b6049378b"></a><!-- doxytag: member="LEVEL_PINCLIENT::ATTACH_CALLBACK" ref="g010d2c9c0916f7d449cca75b6049378b" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g010d2c9c0916f7d449cca75b6049378b">LEVEL_PINCLIENT::ATTACH_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin attaches to application in JIT mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g79fa77e14c506144fd7f053bea02f69a"></a><!-- doxytag: member="LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK" ref="g79fa77e14c506144fd7f053bea02f69a" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g79fa77e14c506144fd7f053bea02f69a">LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin attaches to application in Probe mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gee4246ef0764b57c3d4cf16cfd386530"></a><!-- doxytag: member="LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK" ref="gee4246ef0764b57c3d4cf16cfd386530" args="(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#gee4246ef0764b57c3d4cf16cfd386530">LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#g8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *to, INT32 info, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call-back function when application changes context.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the thread that changes contexts. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>Cause of the context change. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>from</em>&nbsp;</td><td>Application's register state prior to the context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_CALLBACK). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>to</em>&nbsp;</td><td>Application's register state after context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL). The tool may change this and affect the new register state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>Additional information (depends on <em>reason</em>): <ul>
<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g691ef173936cecf038159eea5c1f72d1"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_CALLBACK" ref="g691ef173936cecf038159eea5c1f72d1" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g691ef173936cecf038159eea5c1f72d1">LEVEL_PINCLIENT::DETACH_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin detaches from application in JIT mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g698d5e8e76d0e196c274bec28e4570cd"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK" ref="g698d5e8e76d0e196c274bec28e4570cd" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g698d5e8e76d0e196c274bec28e4570cd">LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin detaches from application in Probe mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0372373ea88181877e8ce7940b50a48e"></a><!-- doxytag: member="LEVEL_PINCLIENT::FETCH_CALLBACK" ref="g0372373ea88181877e8ce7940b50a48e" args="(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(*) <a class="el" href="group__PIN__CONTROL.html#g0372373ea88181877e8ce7940b50a48e">LEVEL_PINCLIENT::FETCH_CALLBACK</a>(void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function that Pin will use to fetch code bytes to be jitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>A buffer which receives the fetched instruction bytes. This buffer is at least <em>size</em> bytes long. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>Starting address from which instruction bytes should be fetched. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes that should be fetched. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>If less than <em>size</em> bytes are fetched, <em>pExceptInfo</em> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sucessfully fetched into <em>buf</em>. This may be less than <em>size</em> (or even zero) if Pin attempts to fetch instructions from an invalid address. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3311decfd798a6b4717705a0d842936e"></a><!-- doxytag: member="LEVEL_PINCLIENT::FINI_CALLBACK" ref="g3311decfd798a6b4717705a0d842936e" args="(INT32 code, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g3311decfd798a6b4717705a0d842936e">LEVEL_PINCLIENT::FINI_CALLBACK</a>(INT32 code, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when application exits. It is called after all the per thread fini functions were called (registered via <a class="el" href="group__PIN__CONTROL.html#ge79d468cc5e19b450603f07f3397203d">PIN_AddThreadFiniFunction</a>). This function may be called on any application thread or internal thread spawned by the tool.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is prohibited to access the TLS in this callback.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>code</em>&nbsp;</td><td>O/S specific termination code for the application. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g805a0df42777e7c3fed4293b957e9517"></a><!-- doxytag: member="LEVEL_PINCLIENT::FORK_CALLBACK" ref="g805a0df42777e7c3fed4293b957e9517" args="(THREADID threadid, const CONTEXT *ctxt, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g805a0df42777e7c3fed4293b957e9517">LEVEL_PINCLIENT::FORK_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call-back function when the application forks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>Thread index </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Register state immediately before/after the fork. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd208f697a16773fe82ac33ee8aec67be"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK" ref="gd208f697a16773fe82ac33ee8aec67be" args="(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BOOL(*) <a class="el" href="group__PIN__CONTROL.html#gd208f697a16773fe82ac33ee8aec67be">LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when the tool intercepts a signal with <a class="el" href="group__PIN__CONTROL.html#g240de32335a0aca3ceee37ad96b1dd12">PIN_InterceptSignal()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the thread that handled the signal. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>The application's register state when it was interrupted by the signal. The tool may change this context if desired. If so, the application continues at the modified context. Or, if the application's signal handler is invoked, the handler is passed the modified context for its return context. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hasHandler</em>&nbsp;</td><td>TRUE if the application has a handler registered for this signal. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>If the signal represents an exception, <em>pExceptInfo</em> points to a description of the exception. If the signal is not an exception, <em>pExceptInfo</em> is NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returning TRUE tells Pin to pass the signal on to the application. Returning FALSE tells Pin to squash the signal and execution resumes at <em>ctxt</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g07c2d0d5846d67bdcb924e0f0aae75fc"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK" ref="g07c2d0d5846d67bdcb924e0f0aae75fc" args="(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__PIN__CONTROL.html#g8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a>(*) <a class="el" href="group__PIN__CONTROL.html#g07c2d0d5846d67bdcb924e0f0aae75fc">LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#g3c6833a027db42b5d528a0c65cefbc07">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handler (call-back) function when pin/tool generates internal exception. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#g60adbdd03078851f0e2611ab06e17c19">PIN_AddInternalExceptionHandler()</a> or <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>. This function becomes active only after APPLICATION_START_CALLBACK notification is delivered. Any internal exception prior to this event can't be handled.<p>
If the exception occurred while analysis routine is executed, it is legal to modify the execution control path using functions such as <a class="el" href="group__EXCEPTION__API.html#g656279818bb8972fbdac576b57854561">PIN_RaiseException()</a> or <a class="el" href="group__CONTEXT__API.html#ga836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>. In this case, any per-thread INTERNAL_EXCEPTION_CALLBACK function registered via <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> will be unregistered automatically (similar semantics to <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> for all registered notifications)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a> in the scope of this callback</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the thread that generated the exception. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>Pointer to the EXCEPTION_INFO structure that describes the exception. If the exception should be raised in the context of the application (using <a class="el" href="group__EXCEPTION__API.html#g656279818bb8972fbdac576b57854561">PIN_RaiseException()</a>), The tool should update the exception info to match the OS logic (e.g. update exception address using <a class="el" href="group__EXCEPTION__API.html#g397741c75f32043c9fcf6525f668678a">PIN_SetExceptionAddress()</a>). </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pPhysCtxt</em>&nbsp;</td><td>Physical register state when the exception was generated. The tool can change <em>pPhysCtxt</em> (make sure that if <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> was called, matching <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> will be called) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <em>EXCEPT_HANDLING_RESULT</em> value </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1f3211dd5ce1c837e967ec9baa3e86fc"></a><!-- doxytag: member="LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK" ref="g1f3211dd5ce1c837e967ec9baa3e86fc" args="(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ADDRINT(PIN_FAST_ANALYSIS_CALL *) <a class="el" href="group__PIN__CONTROL.html#g1f3211dd5ce1c837e967ec9baa3e86fc">LEVEL_PINCLIENT::MEMORY_ADDR_TRANS_CALLBACK</a>(PIN_MEM_TRANS_INFO *memTransInfo, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function for pin/tool to modify memory address arguments in analysis routines. This feature allows users to register for a callback immediately prior to an analysis routine which gets one of the four IARG_MEMORY*_PTR as a parameter. The callback enables the user to manipulate the memory address pointed to by the aforementioned parameter. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#g6d9a4cd860d8168ce1dab07da404752e">PIN_AddMemoryAddressTransFunction()</a>. This function is called from the jitted code, so calls to this function are not serialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memTransInfo</em>&nbsp;</td><td>Memory address data structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4e3a72a2897522238554d8e24e712f49"></a><!-- doxytag: member="LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK" ref="g4e3a72a2897522238554d8e24e712f49" args="(size_t size, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g4e3a72a2897522238554d8e24e712f49">LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK</a>(size_t size, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when pin/tool is out of memory. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#g897b98855a1853146f9d291687f41946">PIN_AddOutOfMemoryFunction()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the failed allocation </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdfef9e89968c6491114d7ceae51ab61b"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CONFIGURATION_INFO" ref="gdfef9e89968c6491114d7ceae51ab61b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID* <a class="el" href="group__PIN__CONTROL.html#gdfef9e89968c6491114d7ceae51ab61b">LEVEL_PINCLIENT::PIN_CONFIGURATION_INFO</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global configuration for Pin. Currently, this configuration includes whether Pin should serialize calls to some callbacks (for backward compatibility) or if it should concurrently call the callbacks (better for multi-threaded performance).<p>
See also: <a class="el" href="group__PIN__CONTROL.html#g48dd43d356a2b768c7c0d3cbc4e1fee6">PIN_SetAllowedConcurrentCallbacks()</a><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A new instance of PIN_CONFIGURATION_INFO with default values should be created with <a class="el" href="group__PIN__CONTROL.html#gbf3035f1cd239935bb4b9d45b39be266">PIN_CreateDefaultConfigurationInfo()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g27bb61b168e41345426b3057dd4122ff"></a><!-- doxytag: member="LEVEL_PINCLIENT::PREPARE_FOR_FINI_CALLBACK" ref="g27bb61b168e41345426b3057dd4122ff" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g27bb61b168e41345426b3057dd4122ff">LEVEL_PINCLIENT::PREPARE_FOR_FINI_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function invoked when Pin is about to detach from terminating process. The function that is registered by this callback may gracefully finish all the internal threads of the tool, e.g.<ul>
<li>Force all the internal threads of the tool to finish using return from the main function of the thread or calling PIN_ExitThread.</li><li>Wait until all the internal threads are finished before it will continue to run. <dl class="note" compact><dt><b>Note:</b></dt><dd>: normal run of the internal threads after exit from all registered call back functions of this type is not guaranteed. <p>
: If current thread is an internal thread, do not finish it in this callback!</dd></dl>
This function is invoked in thread that initiated process termination. This function is registered via <a class="el" href="group__PIN__CONTROL.html#g3ca849f6b9c098afb7769e0845cc52c1">PIN_AddPrepareForFiniFunction()</a>.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g989519cc87af23252e98d16012353ec3"></a><!-- doxytag: member="LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK" ref="g989519cc87af23252e98d16012353ec3" args="(IMG img, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g989519cc87af23252e98d16012353ec3">LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK</a>(IMG img, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function when probe insertion is complete.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>img</em>&nbsp;</td><td>Image. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1fcf0ef617d803b3264c6136f873c726"></a><!-- doxytag: member="LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK" ref="g1fcf0ef617d803b3264c6136f873c726" args="(VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g1fcf0ef617d803b3264c6136f873c726">LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK</a>(VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin removes all old instrumented code from its cache<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6f5b81f46ccb76dd76f8f34c5bdb6ef3"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_FINI_CALLBACK" ref="g6f5b81f46ccb76dd76f8f34c5bdb6ef3" args="(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g6f5b81f46ccb76dd76f8f34c5bdb6ef3">LEVEL_PINCLIENT::THREAD_FINI_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 code, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call-back function when thread ends.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function may be called on a different thread than the given threadIndex.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the terminating thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Register state of the thread immediately before it terminates. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>code</em>&nbsp;</td><td>O/S specific termination code for the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3d6ca92519234f558438455528d98268"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_START_CALLBACK" ref="g3d6ca92519234f558438455528d98268" args="(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) <a class="el" href="group__PIN__CONTROL.html#g3d6ca92519234f558438455528d98268">LEVEL_PINCLIENT::THREAD_START_CALLBACK</a>(<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, INT32 flags, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call-back function when thread begins.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Initial register state for the new thread. The tool may change this. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>O/S specific flags for the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gf9a18d894714ae57264a2302638fc4b3"></a><!-- doxytag: member="LEVEL_PINCLIENT::ATTACH_STATUS" ref="gf9a18d894714ae57264a2302638fc4b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#gf9a18d894714ae57264a2302638fc4b3">LEVEL_PINCLIENT::ATTACH_STATUS</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return values of <a class="el" href="group__PIN__CONTROL.html#g4940c04f3fe39a87090c6872b9ba7e5a">PIN_Attach()</a> and <a class="el" href="group__PIN__CONTROL.html#g5630fbebba55f0b78adb96adccc8daf8">PIN_AttachProbed()</a> which describe the status of the attach request. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggf9a18d894714ae57264a2302638fc4b3b479d68822d4264f3ad10880a5b21a3d"></a><!-- doxytag: member="ATTACH_INITIATED" ref="ggf9a18d894714ae57264a2302638fc4b3b479d68822d4264f3ad10880a5b21a3d" args="" -->ATTACH_INITIATED</em>&nbsp;</td><td>
Attach request was delivered successfully to PIN. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf9a18d894714ae57264a2302638fc4b314afa31e2dadab79279e93630e18f671"></a><!-- doxytag: member="ATTACH_FAILED_DETACH" ref="ggf9a18d894714ae57264a2302638fc4b314afa31e2dadab79279e93630e18f671" args="" -->ATTACH_FAILED_DETACH</em>&nbsp;</td><td>
Attach request was not delivered to Pin since detach session hasn't completed yet. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8e4e6511a0e09fdc5ec7d6dbf395b3a8"></a><!-- doxytag: member="types_vmapi.H::CONTEXT_CHANGE_REASON" ref="g8e4e6511a0e09fdc5ec7d6dbf395b3a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#g8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Possible reasons for an application context change. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e712c798df1d0e94022f6382a4c8239e"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_FATALSIGNAL" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e712c798df1d0e94022f6382a4c8239e" args="" -->CONTEXT_CHANGE_REASON_FATALSIGNAL</em>&nbsp;</td><td>
Receipt of fatal Unix signal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a843b8b032e969e0e5d14a3ed7385f29db"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGNAL" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a843b8b032e969e0e5d14a3ed7385f29db" args="" -->CONTEXT_CHANGE_REASON_SIGNAL</em>&nbsp;</td><td>
Receipt of handled Unix signal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a87e8b6943c9aa3a85b0a9cd23bc738dd9"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGRETURN" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a87e8b6943c9aa3a85b0a9cd23bc738dd9" args="" -->CONTEXT_CHANGE_REASON_SIGRETURN</em>&nbsp;</td><td>
Return from Unix signal handler. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8641c250ce491d66cc19f1205160dc279"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_APC" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8641c250ce491d66cc19f1205160dc279" args="" -->CONTEXT_CHANGE_REASON_APC</em>&nbsp;</td><td>
Receipt of Windows APC. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e4c034a98f8eba91b2f8ac5b2543492b"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_EXCEPTION" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a8e4c034a98f8eba91b2f8ac5b2543492b" args="" -->CONTEXT_CHANGE_REASON_EXCEPTION</em>&nbsp;</td><td>
Receipt of Windows exception. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8e4e6511a0e09fdc5ec7d6dbf395b3a85b48097c22e4fcfdf12650129f364b50"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_CALLBACK" ref="gg8e4e6511a0e09fdc5ec7d6dbf395b3a85b48097c22e4fcfdf12650129f364b50" args="" -->CONTEXT_CHANGE_REASON_CALLBACK</em>&nbsp;</td><td>
Receipt of Windows call-back. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8c5c16fb133375efa3a27d3a3900c603"></a><!-- doxytag: member="types_vmapi.H::EXCEPT_HANDLING_RESULT" ref="g8c5c16fb133375efa3a27d3a3900c603" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#g8c5c16fb133375efa3a27d3a3900c603">EXCEPT_HANDLING_RESULT</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Possible return values of the INTERNAL_EXCEPTION_CALLBACK exception filter function <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg8c5c16fb133375efa3a27d3a3900c60332e365f541f4ea48f730a030185558cd"></a><!-- doxytag: member="EHR_HANDLED" ref="gg8c5c16fb133375efa3a27d3a3900c60332e365f541f4ea48f730a030185558cd" args="" -->EHR_HANDLED</em>&nbsp;</td><td>
Exception is handled. Continue execution with the internal physical context. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8c5c16fb133375efa3a27d3a3900c603b394692e0b4ad2fda77e7597c75c9599"></a><!-- doxytag: member="EHR_UNHANDLED" ref="gg8c5c16fb133375efa3a27d3a3900c603b394692e0b4ad2fda77e7597c75c9599" args="" -->EHR_UNHANDLED</em>&nbsp;</td><td>
Exception is not handled. Execute default system procedure for unhandled exceptions (Windows) or abort the process (Unix) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg8c5c16fb133375efa3a27d3a3900c6031950501612b017bd8db1634f7dc8bf8f"></a><!-- doxytag: member="EHR_CONTINUE_SEARCH" ref="gg8c5c16fb133375efa3a27d3a3900c6031950501612b017bd8db1634f7dc8bf8f" args="" -->EHR_CONTINUE_SEARCH</em>&nbsp;</td><td>
Execute next (upper level) exception filter function, if any. For the uppermost filter, this is the same as EHR_UNHANDLED semantics </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb459bf0034704bf1aa7fa7e192b7dc08"></a><!-- doxytag: member="LEVEL_PINCLIENT::FPOINT" ref="gb459bf0034704bf1aa7fa7e192b7dc08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#gb459bf0034704bf1aa7fa7e192b7dc08">LEVEL_PINCLIENT::FPOINT</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
time of callback notification <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggb459bf0034704bf1aa7fa7e192b7dc08d25e85d29c19e7e0c5a9a768191bbcd7"></a><!-- doxytag: member="FPOINT_BEFORE" ref="ggb459bf0034704bf1aa7fa7e192b7dc08d25e85d29c19e7e0c5a9a768191bbcd7" args="" -->FPOINT_BEFORE</em>&nbsp;</td><td>
Call-back in parent, just before fork. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggb459bf0034704bf1aa7fa7e192b7dc08e95eedd3db4447dda41b3fe76c7013c6"></a><!-- doxytag: member="FPOINT_AFTER_IN_PARENT" ref="ggb459bf0034704bf1aa7fa7e192b7dc08e95eedd3db4447dda41b3fe76c7013c6" args="" -->FPOINT_AFTER_IN_PARENT</em>&nbsp;</td><td>
Call-back in parent, immediately after fork. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggb459bf0034704bf1aa7fa7e192b7dc08b97d0822ccc4bd553feab25fc85412fc"></a><!-- doxytag: member="FPOINT_AFTER_IN_CHILD" ref="ggb459bf0034704bf1aa7fa7e192b7dc08b97d0822ccc4bd553feab25fc85412fc" args="" -->FPOINT_AFTER_IN_CHILD</em>&nbsp;</td><td>
Call-back in child, immediately after fork. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4e114852e46d5d839d6e71e242709777"></a><!-- doxytag: member="types_vmapi.H::PIN_CALLBACK_TYPE" ref="g4e114852e46d5d839d6e71e242709777" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#g4e114852e46d5d839d6e71e242709777">PIN_CALLBACK_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Types of Pin callbacks. These type could be used with the function <a class="el" href="group__PIN__CONTROL.html#g48dd43d356a2b768c7c0d3cbc4e1fee6">PIN_SetAllowedConcurrentCallbacks()</a> <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg4e114852e46d5d839d6e71e242709777f6f04d87615566deb3bd49ec1e3468ef"></a><!-- doxytag: member="PIN_CALLBACK_TYPE_NONE" ref="gg4e114852e46d5d839d6e71e242709777f6f04d87615566deb3bd49ec1e3468ef" args="" -->PIN_CALLBACK_TYPE_NONE</em>&nbsp;</td><td>
None of the callback types. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg4e114852e46d5d839d6e71e242709777e9e0416b9e54e38bc1cf69956f81bc2c"></a><!-- doxytag: member="PIN_CALLBACK_TYPE_SYSCALL" ref="gg4e114852e46d5d839d6e71e242709777e9e0416b9e54e38bc1cf69956f81bc2c" args="" -->PIN_CALLBACK_TYPE_SYSCALL</em>&nbsp;</td><td>
Syscall entry/exit callback. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0244f9b4e34e4eed7d483fa6ec7b70f0"></a><!-- doxytag: member="LEVEL_PINCLIENT::SMC_ENABLE_DISABLE_TYPE" ref="g0244f9b4e34e4eed7d483fa6ec7b70f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#g0244f9b4e34e4eed7d483fa6ec7b70f0">LEVEL_PINCLIENT::SMC_ENABLE_DISABLE_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for controlling Pin's SMC detection 
</div>
</div><p>
<a class="anchor" name="g139152abe353fdff0216a5519d261c73"></a><!-- doxytag: member="LEVEL_PINCLIENT::SYMBOL_INFO_MODE" ref="g139152abe353fdff0216a5519d261c73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PIN__CONTROL.html#g139152abe353fdff0216a5519d261c73">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of supported modes of symbolic information delivery. Used in <a class="el" href="group__PIN__CONTROL.html#gc133406ab660e13f67dd64f27cdf67c6">PIN_InitSymbolsAlt()</a>. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg139152abe353fdff0216a5519d261c73f44e4b240fa01ca6ed3a64acf6022ce4"></a><!-- doxytag: member="NO_SYMBOLS" ref="gg139152abe353fdff0216a5519d261c73f44e4b240fa01ca6ed3a64acf6022ce4" args="" -->NO_SYMBOLS</em>&nbsp;</td><td>
No symbols required. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg139152abe353fdff0216a5519d261c733486158cb738b76b7385310ec8f5b671"></a><!-- doxytag: member="EXPORT_SYMBOLS" ref="gg139152abe353fdff0216a5519d261c733486158cb738b76b7385310ec8f5b671" args="" -->EXPORT_SYMBOLS</em>&nbsp;</td><td>
Only symbols taken from export table are provided (Windows only). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg139152abe353fdff0216a5519d261c7325bfc332ecb53ef24ee4ff743d09bde1"></a><!-- doxytag: member="DEBUG_SYMBOLS" ref="gg139152abe353fdff0216a5519d261c7325bfc332ecb53ef24ee4ff743d09bde1" args="" -->DEBUG_SYMBOLS</em>&nbsp;</td><td>
Debug symbols (Windows only, currently implemented as DEBUG_OR_EXPORT_SYMBOLS). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg139152abe353fdff0216a5519d261c73a07edbcaef24a5dbbe880f20916bd74e"></a><!-- doxytag: member="IFUNC_SYMBOLS" ref="gg139152abe353fdff0216a5519d261c73a07edbcaef24a5dbbe880f20916bd74e" args="" -->IFUNC_SYMBOLS</em>&nbsp;</td><td>
IFUNC symbols (Linux only). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg139152abe353fdff0216a5519d261c73172580d6ba02ac51ce4d3140bdafec07"></a><!-- doxytag: member="DEBUG_OR_EXPORT_SYMBOLS" ref="gg139152abe353fdff0216a5519d261c73172580d6ba02ac51ce4d3140bdafec07" args="" -->DEBUG_OR_EXPORT_SYMBOLS</em>&nbsp;</td><td>
First debug symbols if available, otherwise export symbols (Windows only) </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g4516c650e020cd12a5425b08588d2ae2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddApplicationStartFunction" ref="g4516c650e020cd12a5425b08588d2ae2" args="(APPLICATION_START_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddApplicationStartFunction           </td>
          <td>(</td>
          <td class="paramtype">APPLICATION_START_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called after pin initialization is finished. This notification function is available when pin launches the application and when pin attaches to a running process.<p>
When pin launches the application, this notification function is called on the application's main thread.<p>
When pin attaches to a running process, this notification function is called on a dedicated thread which is not part of the application's threads.<br>
 When it is called, all the application's threads are paused by Pin and are about to be released.<br>
 No new threads can be created by the application at this time.<p>
When Pin starts running a program, it calls into the tool several times in the following order:<br>
 1. Calls the tool's main() function.<br>
 2. If the tool set up a notification with <a class="el" href="group__IMG__BASIC__API.html#g494869187b5d94d7dd346bc9ff49642f">IMG_AddInstrumentFunction()</a>, Pin calls this call-back for each image that is already loaded in the application's address space at the point when Pin attaches to it.<br>
 3. Calls any notification call-backs set up with <a class="el" href="group__PIN__CONTROL.html#g4516c650e020cd12a5425b08588d2ae2">PIN_AddApplicationStartFunction()</a>.<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Function to be called at application start. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32, Intel(R) 64<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g786fd61c9be3c42a1a6deefc71dffadf"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddContextChangeFunction" ref="g786fd61c9be3c42a1a6deefc71dffadf" args="(CONTEXT_CHANGE_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddContextChangeFunction           </td>
          <td>(</td>
          <td class="paramtype">CONTEXT_CHANGE_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called immediately before the application changes context due to receipt of an asynchronous event such as Unix signal or Windows APC.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute immediately before the application changes context. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfc04e55a26e3b74cdebb8c6a1bf5503b"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunction" ref="gfc04e55a26e3b74cdebb8c6a1bf5503b" args="(DETACH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddDetachFunction           </td>
          <td>(</td>
          <td class="paramtype">DETACH_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call func immediately before Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>.<p>
At this stage no more instrumentation/analysis callbacks will be called<p>
This function is called one time for the process. It may be called by any thread. Pin memory is not freed at this moment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute before detaching </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfd8d7788f12ec84f1c81074851ff716d"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed" ref="gfd8d7788f12ec84f1c81074851ff716d" args="(DETACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed           </td>
          <td>(</td>
          <td class="paramtype">DETACH_PROBED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called immediately after Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#g634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>. There can be more than one Detach callback function.<br>
 When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute before detaching </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g50e51f92c7ea2b6d8b271ecf71a7db65"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFetchFunction" ref="g50e51f92c7ea2b6d8b271ecf71a7db65" args="(FETCH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddFetchFunction           </td>
          <td>(</td>
          <td class="paramtype">FETCH_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called to register a function That will become the function that Pin calls to fetch application instructions. Pin sometimes attempt to fetch instructions from an invalid address, and the call-back needs to handle this correctly. If multiple functions are registered using this API, only the last one registered is used<p>
Pin cannot automatically detect self-modifying code (SMC) when a tool uses this API. Therefore, such tools take over responsibility for detecting SMC and must explicitly regenerate all traces within a modified code range if such was detected using PIN_RemoveInstrumentationInRange.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>The tool's call-back function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc167b8d28d255e53a0ac1f6e9edcd3ec"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFiniFunction" ref="gc167b8d28d255e53a0ac1f6e9edcd3ec" args="(FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddFiniFunction           </td>
          <td>(</td>
          <td class="paramtype">FINI_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call func immediately before the application exits. The function is not an instrumentation function--it cannot insert instrumentation. There can be more than one Fini function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function is passed exit code and val </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5f4e19c43f3de21d382c3c4e2442d961"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction" ref="g5f4e19c43f3de21d382c3c4e2442d961" args="(FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction           </td>
          <td>(</td>
          <td class="paramtype">FOLLOW_CHILD_PROCESS_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called before a child/exec-ed process is starting to execute<p>
NOTE: Only one callback can be registered<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux, MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7282900fb6160031936d8b63fecc4e21"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddForkFunction" ref="g7282900fb6160031936d8b63fecc4e21" args="(FPOINT point, FORK_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddForkFunction           </td>
          <td>(</td>
          <td class="paramtype">FPOINT&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORK_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification handler that is called when the application forks a new process. The function can only be used on Linux.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>where</em>&nbsp;</td><td>Tells when to make the call-back and tells whether the parent or child makes the call-back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>Value passed as final parameter to call-back.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g60adbdd03078851f0e2611ab06e17c19"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler" ref="g60adbdd03078851f0e2611ab06e17c19" args="(INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler           </td>
          <td>(</td>
          <td class="paramtype">INTERNAL_EXCEPTION_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a global (not per-thread) notification handler function that is called upon receipt of any unhandled internal exception in Pin or the tool. This handler does not catch exceptions that are generated by the application, nor does it catch exceptions that are handled by <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a>. The handler is active for all the application's threads, it should be called in tool's main() before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>. If it is called after <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> is called, it will be ignored. The user can register up to MAX_IEH_CALLBACKS global notification functions.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should be used for permanent global call-back registration (as opposed to <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> pair which should be used for function scope registration).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6d9a4cd860d8168ce1dab07da404752e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction" ref="g6d9a4cd860d8168ce1dab07da404752e" args="(MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddMemoryAddressTransFunction           </td>
          <td>(</td>
          <td class="paramtype">MEMORY_ADDR_TRANS_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a callback for modifying memory address arguments that are passed to analysis routines. See <a class="el" href="group__PIN__CONTROL.html#g1f3211dd5ce1c837e967ec9baa3e86fc">MEMORY_ADDR_TRANS_CALLBACK</a> for usage details. <br>
<p>
Only one such callback may be registered. <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function is passed the thread id, address, size, read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT <br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g897b98855a1853146f9d291687f41946"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction" ref="g897b98855a1853146f9d291687f41946" args="(OUT_OF_MEMORY_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction           </td>
          <td>(</td>
          <td class="paramtype">OUT_OF_MEMORY_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called when pin/tool is out of memory.<br>
 Try to reduce memory consumption when this notification function is called.<br>
 Any implicit or explicit usage of malloc()/realloc() etc. in this notification function might cause an infinite recursion.<br>
 The call to the notification function is NOT serialized by pin. The user can't assume anything about the locks state while the notification is delivered (as out of memory condition can occur anywhere). Avoid dead-locks by careful design of the notification function.<br>
<p>
A tool can register only one notification function.<br>
 A new notification function registration overwrites any previous registration.<br>
 To disable the notification function, pass a NULL function pointer.<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function is passed the size of the failing allocation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3ca849f6b9c098afb7769e0845cc52c1"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddPrepareForFiniFunction" ref="g3ca849f6b9c098afb7769e0845cc52c1" args="(PREPARE_FOR_FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddPrepareForFiniFunction           </td>
          <td>(</td>
          <td class="paramtype">PREPARE_FOR_FINI_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a function to be called when the application is about to exit. The registered function will be executed in a thread that initiated the exit and currently does not hold any thread synchronization lock in Pin. It means that this callback function can be executed concurrently with other Pin callbacks and APIs.<br>
 All callbacks registered by this function will be executed before any callback registered by the <a class="el" href="group__PIN__CONTROL.html#gc167b8d28d255e53a0ac1f6e9edcd3ec">PIN_AddFiniFunction()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Callback function to be registered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Function registered by this API after application exit is started, may not be executed.<p>
The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g234255869a62bce07edda25d34ffd5b7"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction" ref="g234255869a62bce07edda25d34ffd5b7" args="(PROBES_INSERTED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction           </td>
          <td>(</td>
          <td class="paramtype">PROBES_INSERTED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called when Pin has inserted all probes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>img</em>&nbsp;</td><td>Image. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Callback function to execute when probe insertion is complete. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g697a1abfcdcc139915c008190aba9dcb"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadAttachFunction" ref="g697a1abfcdcc139915c008190aba9dcb" args="(THREAD_ATTACH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadAttachFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_ATTACH_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is useful when Pin is run in JIT mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.<p>
After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <a class="el" href="group__IMG__BASIC__API.html#g494869187b5d94d7dd346bc9ff49642f">IMG_AddInstrumentFunction()</a>) and then notifies the tool that initialization is complete (see <a class="el" href="group__PIN__CONTROL.html#g4516c650e020cd12a5425b08588d2ae2">PIN_AddApplicationStartFunction()</a>). After that, each thread in the application calls the notification set up by <a class="el" href="group__PIN__CONTROL.html#g697a1abfcdcc139915c008190aba9dcb">PIN_AddThreadAttachFunction()</a>. After each thread returns from this notification, it resumes execution in the application code.<p>
Note, this notification happens only for threads that exist in the process at the time that Pin attaches.<p>
It does not happen for the following threads: 1. Threads that are created in the process after Pin is already attached. 2. Internal threads spawned by Pin tool when Pin re-attaches to the application.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the attached thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6bdae30ea6adc711a3ae04aed47bc222"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction" ref="g6bdae30ea6adc711a3ae04aed47bc222" args="(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_ATTACH_PROBED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is useful when Pin is run in probe mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.<p>
After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <a class="el" href="group__IMG__BASIC__API.html#g494869187b5d94d7dd346bc9ff49642f">IMG_AddInstrumentFunction()</a>) and then notifies the tool that initialization is complete (see <a class="el" href="group__PIN__CONTROL.html#g4516c650e020cd12a5425b08588d2ae2">PIN_AddApplicationStartFunction()</a>). After that, each thread in the application calls the notification set up by <a class="el" href="group__PIN__CONTROL.html#g6bdae30ea6adc711a3ae04aed47bc222">PIN_AddThreadAttachProbedFunction()</a>. After each thread returns from this notification, it resumes execution in the application code.<p>
Note, this notification happens only for threads that exist in the process at the time that Pin attaches. It does not happen for threads that are created in the process after Pin is already attached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the attached thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7f157496433d50573d2f025beca83e5a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadDetachFunction" ref="g7f157496433d50573d2f025beca83e5a" args="(THREAD_DETACH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadDetachFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_DETACH_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is useful when Pin runs in JIT mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before Pin detaches from the thread. This notification is given in the thread native context.<p>
Note, this notification happens only for application threads that exist in the process at the time that Pin detaches. It does not happen for the following threads: 1. Threads that are created in the process after Pin is already detached. 2. Internal threads spawned by Pin tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute by the detaching thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge579102abbf9c663827c82b867db63ad"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction" ref="ge579102abbf9c663827c82b867db63ad" args="(THREAD_DETACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadDetachProbedFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_DETACH_PROBED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is useful when Pin runs in probe mode and detaches from a running process. Tools may use this API to register a notification that is called by each application thread before any probes removal. This notification is given in the thread native context.<p>
Note, this notification happens only for threads that exist in the process at the time that Pin detaches. It does not happen for threads that are created in the process after Pin is already detached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute by the detaching thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge79d468cc5e19b450603f07f3397203d"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadFiniFunction" ref="ge79d468cc5e19b450603f07f3397203d" args="(THREAD_FINI_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadFiniFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_FINI_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called when an application thread terminates. The call-back happens even for the application's root (initial) thread.<p>
The notification call-back will often happen on the physical thread that is exiting, but under some circumstances it will be called on a different physical thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the terminating thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g93431bb0680a22395327ac7d8bb0c14c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadStartFunction" ref="g93431bb0680a22395327ac7d8bb0c14c" args="(THREAD_START_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::PIN_AddThreadStartFunction           </td>
          <td>(</td>
          <td class="paramtype">THREAD_START_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a notification function that is called when a thread starts executing in the application. The call-back happens even for the application's root (initial) thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4940c04f3fe39a87090c6872b9ba7e5a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Attach" ref="g4940c04f3fe39a87090c6872b9ba7e5a" args="(ATTACH_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATTACH_STATUS LEVEL_PINCLIENT::PIN_Attach           </td>
          <td>(</td>
          <td class="paramtype">ATTACH_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiate Pin attach request in JIT mode. If Pin was not detached (using <a class="el" href="group__PIN__CONTROL.html#g634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>) this function will be ignored.<br>
 The given notification function will be called immediately after Pin regains control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <a class="el" href="group__IMG__BASIC__API.html#g494869187b5d94d7dd346bc9ff49642f">IMG_AddInstrumentFunction()</a>) and will reconfigure itself (if needed). In order to change tool's KNOB value, use <a class="el" href="group__KNOB__BASIC.html">KNOB: Basics</a><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Pin's state can't be reconfigured in the scope of the callback function (don't use <a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a>, <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a>, <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> etc.)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute when starting to attach </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>status of attach request (ATTACH_STATUS)</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA32, Intel64<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5630fbebba55f0b78adb96adccc8daf8"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AttachProbed" ref="g5630fbebba55f0b78adb96adccc8daf8" args="(ATTACH_PROBED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATTACH_STATUS LEVEL_PINCLIENT::PIN_AttachProbed           </td>
          <td>(</td>
          <td class="paramtype">ATTACH_PROBED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiate Pin attach request in probe mode. If Pin was not detached (using <a class="el" href="group__PIN__CONTROL.html#g634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>) this function will be ignored.<br>
 The given notification function will be called immediately after Pin regain control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <a class="el" href="group__IMG__BASIC__API.html#g494869187b5d94d7dd346bc9ff49642f">IMG_AddInstrumentFunction()</a>) and will reconfigure itself (if needed). In order to change tool's KNOB value, use <a class="el" href="group__KNOB__BASIC.html">KNOB: Basics</a><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Pin's state can't be reconfigured in the scope of the callback function (don't use <a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a>, <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a>, <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> etc.)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute when starting to attach </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>status of attach request (ATTACH_STATUS)</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA32, Intel64<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5ae5853e6600a23f9c552cba784870cc"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CallApplicationFunction" ref="g5ae5853e6600a23f9c552cba784870cc" args="(const CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr, CALL_APPLICATION_FUNCTION_PARAM *param,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_CallApplicationFunction           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PROTO__API.html#gcfd9f3c8dc22310ce9b9152e8c61b17c">CALLINGSTD_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>cstype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>origFunPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCALL__APPLICATION__FUNCTION__PARAM.html">CALL_APPLICATION_FUNCTION_PARAM</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API allows a tool to call a function inside the application. The function is executed under control of Pin's JIT compiler, and the application code is instrumented normally. Tools should not make direct calls to application functions when Pin is in JIT mode.<p>
<a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a> can be called from a replacement routine or an analysis routine, but not from a call-back. Note that this API can result in recursive execution in the tool since the called application function is also instrumented.<p>
One usage model for this API is to "wrap" an application function, executing analysis code before the function is called and after it returns. To do this, use <a class="el" href="group__RTN__BASIC__API.html#g2dcaf2242c7a62151d89c01e2f04f8c0">RTN_ReplaceSignature()</a> to replace the application function, use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a> to pass the original function pointer to the replacement routine, and use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> to pass the register state. You can then call back on the original function from your replacement routine with <a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a>. Note, however, that the overhead of <a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a> can be high, so it is more efficient to use *_InsertCall() instead if possible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>The application register state to use when calling the function. Pin changes the register state in order to pass arguments to the function, but the <em>ctxt</em> parameter isn't changed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin id of the current thread (see <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cstype</em>&nbsp;</td><td>The calling standard used for calling this function (CALLINGSTD_DEFAULT recommended). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origFunPtr</em>&nbsp;</td><td>The entry point of the application function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>param</em>&nbsp;</td><td>Additional parameters to define the exact behavior of this function invocation (or NULL for using the defaults). See <a class="el" href="structCALL__APPLICATION__FUNCTION__PARAM.html">CALL_APPLICATION_FUNCTION_PARAM</a> . </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td>List of function argument type and size.</td></tr>
  </table>
</dl>
See <a class="el" href="group__PROTO__API.html#gcb4faa1f3649fce55756313c6259519f">PIN_PARG</a> for the recommended method of passing function arguments. <a class="el" href="group__PROTO__API.html#geebb4a42707b704ebf214a06a6bf4e62">PIN_PARG_END()</a> must end the argument list, even if the function has no arguments. If the application function has a return value, it must appear first in the argument list.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT only<br>
 <b>O/S</b>: Linux and Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g97c4af33bb0a330a0967c80c61fcd1c4"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CheckReadAccess" ref="g97c4af33bb0a330a0967c80c61fcd1c4" args="(VOID *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_CheckReadAccess           </td>
          <td>(</td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an address, this API checks whether the memory page which contains this address has a read access protection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>memory address</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the memory page which contains the given address has a read access protection, false otherwise.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="group__PIN__CONTROL.html#g97c4af33bb0a330a0967c80c61fcd1c4">PIN_CheckReadAccess()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1c7bfe02dcbcc4415ef03a7267a1b11"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CheckWriteAccess" ref="gb1c7bfe02dcbcc4415ef03a7267a1b11" args="(VOID *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_CheckWriteAccess           </td>
          <td>(</td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an address, this API checks whether the memory page which contains this address has a write access protection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>memory address</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the memory page which contains the given address has a write access protection, false otherwise.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="group__PIN__CONTROL.html#gb1c7bfe02dcbcc4415ef03a7267a1b11">PIN_CheckWriteAccess()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.<p>
PIN_CheckWriteAccess assume that if a memory page has a write access protection it also has a read</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbf3035f1cd239935bb4b9d45b39be266"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CreateDefaultConfigurationInfo" ref="gbf3035f1cd239935bb4b9d45b39be266" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CONFIGURATION_INFO LEVEL_PINCLIENT::PIN_CreateDefaultConfigurationInfo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of PIN_CONFIGURATION_INFO with default values. This instance can be passed to <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> in order to take effect on Pin.<p>
The default values are:<ul>
<li>Callback types which are allowed to run concurrently - None (PIN_CALLBACK_TYPE_NONE)</li></ul>
<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6277d16bf33ede39685a26a92fc3cbef"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Detach" ref="g6277d16bf33ede39685a26a92fc3cbef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_Detach           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pin relinquishes control of the application and the original un-instrumented code is executed.<p>
On Linux, the function may be invoked from analysis, instrumentation or callback routines. It may be executed by any thread, including threads spawned by the Pintool which are invisible to the Pin VM.<p>
On Windows and OS X*, the function must be invoked from an analysis routine. Invoking the function from instrumentation routines could cause Pin to misbehave. See Tests/detach.C for an example of its use.<p>
The request for detach is considered by Pin as asynchronous. This means that Pin will perform the detach procedure at a point which it considers convenient to do so. From the user's perspective, instrumentation, analysis or callback routines might still be executed after calling <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>. In practice, <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a> simply registers the request to the Pin VM and exits immediately i.e. the function does not wait for detach to complete.<p>
Once Pin starts the detach procedure, it can't be blocked, and will not run forever. It is not possible to detach one thread. All threads will run natively after <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach()</a>. During detach, Pin doesn't free memory used for Pin objects. This memory will be used during re-attach.<p>
During the detach procedure Pin runs an auxiliary process, which communicates with the running application process via debug interface. The auxiliary process is temporary and will exit immediately when the detach procedure is completed. For the user, this means that a debugger cannot be attached to the application process during detach.<p>
Use <a class="el" href="group__PIN__CONTROL.html#gfc04e55a26e3b74cdebb8c6a1bf5503b">PIN_AddDetachFunction()</a> to receive a notification just prior to detach. The callback will be received after all the threads are stopped inside the VM and no more instrumentation functions, analysis routines or callbacks will be called.<br>
 Note: at this point, the auxiliary process mentioned above is still attached to the application process.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm and client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows, &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g634584cd69b124a7edd58655010e295f"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DetachProbed" ref="g634584cd69b124a7edd58655010e295f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_DetachProbed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiate Pin detach request in probe mode. In the scope of this operation, Pin removes all probes set by Pin &amp; tool, The user can get a notification when the detach operation has been completed (via callback registration using <a class="el" href="group__PIN__CONTROL.html#gfd8d7788f12ec84f1c81074851ff716d">PIN_AddDetachFunctionProbed()</a>). On Linux, the user can get additional per-thread callbacks just prior to probes removal. (via callback registration using <a class="el" href="group__PIN__CONTROL.html#ge579102abbf9c663827c82b867db63ad">PIN_AddThreadDetachProbedFunction()</a>).These callbacks will be given for each thread in its native context. If Pin has already detached (using <a class="el" href="group__PIN__CONTROL.html#g634584cd69b124a7edd58655010e295f">PIN_DetachProbed()</a>), or if Pin has not fully started yet (the notification function registered by <a class="el" href="group__PIN__CONTROL.html#g4516c650e020cd12a5425b08588d2ae2">PIN_AddApplicationStartFunction()</a> was not yet delivered to the tool), this function will be ignored.<br>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Even though Pin removes all probes, replacement functions can still be active (for example, if the replacement function is still located on the call stack of one of the threads). It is the tool responsibility to handle these scenarios.<br>
<p>
The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows, &amp; OS X*<br>
 <b>CPU:</b> IA32, Intel64<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g29ad6213c90cfee4a67640798c0c2501"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_FetchCode" ref="g29ad6213c90cfee4a67640798c0c2501" args="(void *copyBuf, const VOID *address, size_t maxSize, EXCEPTION_INFO *pExceptInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LEVEL_PINCLIENT::PIN_FetchCode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>copyBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *&nbsp;</td>
          <td class="paramname"> <em>pExceptInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function to fetch the code raw bytes.<p>
This function should be used when the tool needs the raw bytes of instructions and the tool is using a code fetcher function that translates the original code address to an actual code address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>copyBuf</em>&nbsp;</td><td>destination buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>address to copy from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxSize</em>&nbsp;</td><td>number of bytes to copy </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>pointer to the structure that receives the exception information</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0df38f14792706f4377486473c0bb382"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetAuxVectorValue" ref="g0df38f14792706f4377486473c0bb382" args="(ADDRINT type, bool *found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::PIN_GetAuxVectorValue           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>found</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an aux vector entry type, returns the entry's value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type of the desired auxv entry. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>found</em>&nbsp;</td><td>True if the entry was found, false otherwise.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the aux vector entry, undefined if .</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT/Probe<br>
 <b>O/S</b>: Linux <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4494aa98db78e24a10caec922404200e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetInitialThreadCount" ref="g4494aa98db78e24a10caec922404200e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::PIN_GetInitialThreadCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is useful when the tool that use attach is doing some initial work that needs the number of threads at the time of the attach.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of threads at the time of the attach, in all other cases it will return one. It is not implemented for Windows with attach.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT/Probe<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8852a4e2eb765b1356069037bdf05f83"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction" ref="g8852a4e2eb765b1356069037bdf05f83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMORY_ADDR_TRANS_CALLBACK LEVEL_PINCLIENT::PIN_GetMemoryAddressTransFunction           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Registered notification function that is called when tool needs to modify memory address in PIN.<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function has no parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g783d3bd40c3fb2ca51b1f9af31a70c9c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Init" ref="g783d3bd40c3fb2ca51b1f9af31a70c9c" args="(INT32 argc, CHAR **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_Init           </td>
          <td>(</td>
          <td class="paramtype">INT32&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR **&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize Pin system. Must be called before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>argc value passed to main </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>argv value passed to main, encoded in UTF8 (a superset of ASCII)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if an error was detected parsing the command line</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8cf4aca0b0bdbc7fc0ae965883d8e3c2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InitSymbols" ref="g8cf4aca0b0bdbc7fc0ae965883d8e3c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_InitSymbols           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize symbol table code. Pin does not read symbols unless this is called. Must be called before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram</a><p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc133406ab660e13f67dd64f27cdf67c6"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InitSymbolsAlt" ref="gc133406ab660e13f67dd64f27cdf67c6" args="(SYMBOL_INFO_MODE mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_InitSymbolsAlt           </td>
          <td>(</td>
          <td class="paramtype">SYMBOL_INFO_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize symbol table code with an explicitly specified mode of symbol support. <br>
 Pin does not read symbols unless this is called. <br>
 Must be called before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram</a>. <br>
 Alternative to <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a> on Windows &amp; Linux. <br>
 On MacOS it is implemented as <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a> <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>Explicit mode of symbol support. Valid values: <br>
 EXPORT_SYMBOLS Only symbols taken from export table are provided. Line information is not available (Windows only). <br>
 DEBUG_SYMBOLS Currently treated the same as DEBUG_OR_EXPORT_SYMBOLS (Windows only). <br>
 IFUNC_SYMBOLS IFUNC symbols (Linux only). <br>
 DEBUG_OR_EXPORT_SYMBOLS First debug symbols if available, otherwise export symbols. This mode is set by <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a> (Windows only) <br>
 This parameter is ignored on operating systems other than Windows &amp; Linux. <br>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the operation succeeded <br>
</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g163322863f36bbbeef986c94d319eef0"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InsertCallProbed" ref="g163322863f36bbbeef986c94d319eef0" args="(ADDRINT addr, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_InsertCallProbed           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to an analysis routine relative to a location. In this location we expect to find a safe instruction, i.e. an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the application address to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>the analysis function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. The list must end with IARG_END.</td></tr>
  </table>
</dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: All<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g240de32335a0aca3ceee37ad96b1dd12"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InterceptSignal" ref="g240de32335a0aca3ceee37ad96b1dd12" args="(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_InterceptSignal           </td>
          <td>(</td>
          <td class="paramtype">INT32&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTERCEPT_SIGNAL_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish an interceptor function for signals delivered to the application. Tools should never call sigaction() directly to handle signals. The interceptor function is called whenever the application receives the requested signal, regardless of whether the application has a handler for that signal. The tool's handler can then decide whether the signal should be forwarded to the application.<p>
There are two intended usage models for this API, which are both advanced features. If your tool merely needs to be notified of signals that are sent to the application, use <a class="el" href="group__PIN__CONTROL.html#g786fd61c9be3c42a1a6deefc71dffadf">PIN_AddContextChangeFunction()</a> instead.<p>
In one usage model, a tool can take over ownership of a signal in order to use the signal as an asynchronous communication mechanism to the outside world. For example, if a tool intercepts SIGUSR1, a user of the tool could send this signal and tell the tool to do something. In this usage model, the tool may want to call <a class="el" href="group__PIN__CONTROL.html#gc7795f34b4a267644e4d10b288c38d96">PIN_UnblockSignal()</a> so that it will receive the signal even if the application attempts to block it.<p>
In the second usage model, the tool may need to "squash" certain signals that the application generates. For example, a tool that forces speculative execution in the application may want to intercept and squash exceptions generated in the speculative code.<p>
A tool can set only one "intercept" handler for a particular signal, so a new handler overwrites any previous handler for the same signal. To disable a handler, pass a NULL function pointer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number to intercept, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>The tool's intercept function, or NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the intercept function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc671358905f7d4dac7d544b6048e3ee3"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsActionPending" ref="gc671358905f7d4dac7d544b6048e3ee3" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsActionPending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is useful when an analysis routine might block for an indefinite period of time. In such cases, the analysis code can periodically call <a class="el" href="group__PIN__CONTROL.html#gc671358905f7d4dac7d544b6048e3ee3">PIN_IsActionPending()</a> to see if the thread has some pending action that needs to be handled in the Pin VM. If so, the analysis routine should return back to the VM, either by returning or by calling <a class="el" href="group__CONTEXT__API.html#ga836395fa2c09ed62f85d74b46970659">PIN_ExecuteAt()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The ID of the calling thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the thread has a pending action in the Pin VM.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbb4b02d78ee780c3b70e86a86ff798cd"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsAttaching" ref="gbb4b02d78ee780c3b70e86a86ff798cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsAttaching           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if Pin is being attached to a running application process </dd></dl>

</div>
</div><p>
<a class="anchor" name="g294137f03b1d950d0f1f95968979b490"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsProbeMode" ref="g294137f03b1d950d0f1f95968979b490" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsProbeMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return TRUE if -probe on command line or if Tool started application calling <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a>.<br>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Tool can run in Probe mode without specifying -probe on the command line. This switch is provided as a convenience. In that case, <a class="el" href="group__PIN__CONTROL.html#g294137f03b1d950d0f1f95968979b490">PIN_IsProbeMode()</a> will return FALSE before <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> was called (Since the default running mode is JIT).</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g389d27155d820029712f396a2a824370"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion" ref="g389d27155d820029712f396a2a824370" args="(ADDRINT addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the given location is safe for probe insertion. This means that the location contains an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the application address to instrument </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE/FALSE if the location is safe</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: All<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdf5abd51ee9b1d599c539a9e2784e9ef"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_LockClient" ref="gdf5abd51ee9b1d599c539a9e2784e9ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_LockClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Some Pin API functions may only be called when the thread is holding this lock. See also <a class="el" href="group__PIN__CONTROL.html#ga6239dd852b5236f75413209aceb7a79">PIN_UnlockClient</a>. The client lock is recursive, so can be claimed again by a thread if it already holds it. PIN_LockClient and PIN_UnlockClient calls must be matched, since the lock implementation maintains a depth count.<br>
 This function can be used in any thread, including internal threads spawned by the tool.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfc1635c2b2550236a66dcba25f9cc8a7"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveFiniFunctions" ref="gfc1635c2b2550236a66dcba25f9cc8a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveFiniFunctions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates all the Fini callback functions registered via <a class="el" href="group__PIN__CONTROL.html#gc167b8d28d255e53a0ac1f6e9edcd3ec">PIN_AddFiniFunction</a>; Fini callbacks will no longer be called before the application exits.<p>
Must be called prior to invoking <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach</a> if the tool has previously registered Fini callbacks and libc.so is not yet loaded into memory yet for a dynamically linked binary.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7f5784c3b9431086f3b5b750912ca0c2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveInstrumentation" ref="g7f5784c3b9431086f3b5b750912ca0c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveInstrumentation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All instrumentation is removed. When application code is executed the instrumentation routines will be called to reinstrument all code. Similarly, any ahead-of-time instrumentation will be reapplied if the relevant code is re-executed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf896499ed7402ef4e34baaa64626e0bd"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveInstrumentationInRange" ref="gf896499ed7402ef4e34baaa64626e0bd" args="(ADDRINT start, ADDRINT end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_RemoveInstrumentationInRange           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all instrumentation from the given range [start,end]. If the application reaches this range again, the code will be reinstrumented. Can be called from an analysis function or a callback. Note: Some code beyond the start and end margins may be reinstrumented as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The starting address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The ending address (inclusive) of the range</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g98669d2f5629027689d60bd852ffa0eb"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopy" ref="g98669d2f5629027689d60bd852ffa0eb" args="(VOID *dst, const VOID *src, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LEVEL_PINCLIENT::PIN_SafeCopy           </td>
          <td>(</td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
Tools should use this function to ensure safe access to the original content of the application's memory. For example, on Windows, Pin replaces certain TEB fields when running analysis routines in the tool. If the tool accesses these fields directly, it would see the values assigned by Pin rather than the original ones. On the contrary, <a class="el" href="group__PIN__CONTROL.html#g98669d2f5629027689d60bd852ffa0eb">PIN_SafeCopy()</a> always reads and modifies the original application's values of these fields.<p>
This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>destination region </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>region to copy from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to copy</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="group__PIN__CONTROL.html#g98669d2f5629027689d60bd852ffa0eb">PIN_SafeCopy()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g271a2d60a060ddd0c13d6599afe8c0e2"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopyEx" ref="g271a2d60a060ddd0c13d6599afe8c0e2" args="(VOID *dst, const VOID *src, size_t size, EXCEPTION_INFO *pExceptInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LEVEL_PINCLIENT::PIN_SafeCopyEx           </td>
          <td>(</td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__EXCEPTION__API.html#g95d87b1df51db38b0c1ed311a1fff5a5">EXCEPTION_INFO</a> *&nbsp;</td>
          <td class="paramname"> <em>pExceptInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
In addition to the <a class="el" href="group__PIN__CONTROL.html#g98669d2f5629027689d60bd852ffa0eb">PIN_SafeCopy</a> functionality, this function allows the tool to obtain detailed exception information in case of failure.<p>
This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>destination region </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>region to copy from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to copy </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>pointer to the structure that receives the exception information in case of failure.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region. If the function fails to copy all bytes, it provides detailed description of the failure in the <em></em> &lt;pExceptInfo&gt; structure.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The exception address in the returned exception information always has zero value. If the tool wants to raise this exception on behalf of the application, it should use <a class="el" href="group__EXCEPTION__API.html#g397741c75f32043c9fcf6525f668678a">PIN_SetExceptionAddress</a> function to set an appropriate exception address before passing the exception information to the <a class="el" href="group__EXCEPTION__API.html#g656279818bb8972fbdac576b57854561">PIN_RaiseException</a> function.<p>
<a class="el" href="group__PIN__CONTROL.html#g271a2d60a060ddd0c13d6599afe8c0e2">PIN_SafeCopyEx()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g48dd43d356a2b768c7c0d3cbc4e1fee6"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SetAllowedConcurrentCallbacks" ref="g48dd43d356a2b768c7c0d3cbc4e1fee6" args="(PIN_CONFIGURATION_INFO options, PIN_CALLBACK_TYPE callbackType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SetAllowedConcurrentCallbacks           </td>
          <td>(</td>
          <td class="paramtype">PIN_CONFIGURATION_INFO&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__CONTROL.html#g4e114852e46d5d839d6e71e242709777">PIN_CALLBACK_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>callbackType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables/disables concurrent delivery of certain callbacks in a specific PIN_CONFIGURATION_INFO instance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>The <a class="el" href="group__PIN__CONTROL.html#gdfef9e89968c6491114d7ceae51ab61b">PIN_CONFIGURATION_INFO</a> instance to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callbackType</em>&nbsp;</td><td>Specifies which Pin callbacks are allowed to be delivered concurrently:<br>
<br>
 In the case where a callback should be delivered to several threads at a given moment, delivering a callback concurrently means that each thread is free to deliver its the respective callbacks without waiting for the other threads. This means that Pin doesn't acquire any exclusive internal lock in order to deliver a concurrent callback<br>
<br>
 In constrast, delivering a callback in a serialized way means that, in a given moment, only one threads is allowed to deliver any type of callback. Serializing the callback might hurt the performance of your Pin tool, but it will protect the tool against possibly race conditions in your tool. When a callback is considered "serialized", Pin will acquire an exclusive internal lock before delivering the callback to the tool.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In order for this option to take effect the <a class="el" href="group__PIN__CONTROL.html#gdfef9e89968c6491114d7ceae51ab61b">PIN_CONFIGURATION_INFO</a> must be passed to <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.<p>
Currently, other types of callbacks (which don't have a respective enum entry in <a class="el" href="group__PIN__CONTROL.html#g4e114852e46d5d839d6e71e242709777">PIN_CALLBACK_TYPE</a>) are serialized by Pin with no option to change that.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gec69b96ad1f34e000f56a06abfd1311b"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SetSmcSupport" ref="gec69b96ad1f34e000f56a06abfd1311b" args="(SMC_ENABLE_DISABLE_TYPE enable_disable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_SetSmcSupport           </td>
          <td>(</td>
          <td class="paramtype">SMC_ENABLE_DISABLE_TYPE&nbsp;</td>
          <td class="paramname"> <em>enable_disable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable/Disable Pin's support of self modifying code When enabled, Pin will detect self modification of code and will deliver a callback, if one is registered, when such an event happens. When disabled and if SMC occurs, the SMC will not be detected and the original code will continue to execute. This function takes precedence over the specification of smc_support in the invocation line. This function must be called before PIN_StartProgram.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>SMC_ENABLE, or SMC_DISABLE</td></tr>
  </table>
</dl>
SMC support is enabled by default<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows,Linux,OS X,Adroid<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gded401aeb030a76ee3396137b06ad808"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgram" ref="gded401aeb030a76ee3396137b06ad808" args="(PIN_CONFIGURATION_INFO options=PIN_CreateDefaultConfigurationInfo())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_StartProgram           </td>
          <td>(</td>
          <td class="paramtype">PIN_CONFIGURATION_INFO&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>PIN_CreateDefaultConfigurationInfo()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts executing the application, when Pin is in JIT mode, which is the default. Note that <a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Pin global configuration to use in this run of Pin. These configuration options are set only once (during the call of <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>), and they are affecting the entire execution of Pin.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.<p>
The vm and pin client locks are obtained during the call of this API.</dd></dl>
See also: <a class="el" href="group__PIN__CONTROL.html#gbf3035f1cd239935bb4b9d45b39be266">PIN_CreateDefaultConfigurationInfo()</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g01a31bf221500b0ca0b97fb64cc62247"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgramProbed" ref="g01a31bf221500b0ca0b97fb64cc62247" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_StartProgramProbed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts executing the application, when Pin is in Probe mode. Note that <a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a>.<p>
The <a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc266390e4b69a624a88adcda64ac86c8"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_ToolFullPath" ref="gc266390e4b69a624a88adcda64ac86c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CHAR* LEVEL_PINCLIENT::PIN_ToolFullPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns full path of main Pin tool binary image, encoded in UTF8 (superset of ASCII).<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4b5c7f34928a2594509ba69baf404129"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryEnd" ref="g4b5c7f34928a2594509ba69baf404129" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_TryEnd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister the last registered notification function (registered via <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>) from the context of the calling thread. This function should be called in the same function scope as the previously registered <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a>.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Id of the calling thread.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g75d9372356e0cda2acb7f5851d328575"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryStart" ref="g75d9372356e0cda2acb7f5851d328575" args="(THREADID tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_TryStart           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTERNAL_EXCEPTION_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a per-thread notification handler function that is called upon receipt of an internal exception in pin or the tool in the context of the calling thread. Use <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> in order to remove the registered handler from the context of the calling thread (do it in the same function scope). The user can register up to MAX_IEH_CALLBACKS per-thread notification functions.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#g5ae5853e6600a23f9c552cba784870cc">PIN_CallApplicationFunction()</a> in the scope of <a class="el" href="group__PIN__CONTROL.html#g75d9372356e0cda2acb7f5851d328575">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g4b5c7f34928a2594509ba69baf404129">PIN_TryEnd()</a> pair.<br>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Id of the calling thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the handler function.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc7795f34b4a267644e4d10b288c38d96"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnblockSignal" ref="gc7795f34b4a267644e4d10b288c38d96" args="(INT32 sig, BOOL enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_UnblockSignal           </td>
          <td>(</td>
          <td class="paramtype">INT32&nbsp;</td>
          <td class="paramname"> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API is normally used in conjunction with <a class="el" href="group__PIN__CONTROL.html#g240de32335a0aca3ceee37ad96b1dd12">PIN_InterceptSignal()</a> to prevent the application from blocking a signal that the tool intercepts. This is useful if the tool wants to ensure that the application will not prevent the tool from receiving the intercepted signal.<p>
When this API is called before <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>, it affects all threads in the application. However, if it is called after <a class="el" href="group__PIN__CONTROL.html#gded401aeb030a76ee3396137b06ad808">PIN_StartProgram()</a>, it only affects the calling thread. If the application spawns a thread, the child thread inherits the signal blocking state from its parent.<p>
Tools should take care when using this API because it can adversely affect the application if it also uses the signal <em>sig</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>If TRUE, the application is prevented from blocking <em>sig</em>. If FALSE, the application may block or unblock <em>sig</em> at will.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga6239dd852b5236f75413209aceb7a79"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnlockClient" ref="ga6239dd852b5236f75413209aceb7a79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_UnlockClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Some Pin API functions may be called only when the thread is holding this lock. See also <a class="el" href="group__PIN__CONTROL.html#gdf5abd51ee9b1d599c539a9e2784e9ef">PIN_LockClient</a>.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb047eba18942e83814934eda278de607"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_VmFullPath" ref="gb047eba18942e83814934eda278de607" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CHAR* LEVEL_PINCLIENT::PIN_VmFullPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns full path of Pin binary invoked, encoded in UTF8 (superset of ASCII), this is supported for Linux (only for locales encoded in UTF8).<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jan 28 23:35:32 2018 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
