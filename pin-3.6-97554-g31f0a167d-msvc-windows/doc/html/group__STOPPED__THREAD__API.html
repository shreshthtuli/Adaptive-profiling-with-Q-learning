<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Stop, examine and resume application threads API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Stop, examine and resume application threads API</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g548ed1631804b58caa91ab40970bea87">LEVEL_PINCLIENT::PIN_StopApplicationThreads</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#gb83ac31abfc4074429c4b5cde43dbca1">LEVEL_PINCLIENT::PIN_IsThreadStoppedInDebugger</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g3b14a74ff766a0ddf12f591d53e08d2b">LEVEL_PINCLIENT::PIN_ResumeApplicationThreads</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g728fc728138b1049d1785f46cd8cd310">LEVEL_PINCLIENT::PIN_GetStoppedThreadCount</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g117be31fa21b8be7e73d0ef8376e2d11">LEVEL_PINCLIENT::PIN_GetStoppedThreadId</a> (UINT32 i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g50dac280d3e41bea9b48974231f43dab">LEVEL_PINCLIENT::PIN_GetStoppedThreadContext</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__STOPPED__THREAD__API.html#g7154fed50af7d888d5bfd04bd70b7396">LEVEL_PINCLIENT::PIN_GetStoppedThreadWriteableContext</a> (<a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This API allows the user to stop all application threads, examine and modify their state and then resume them. It is available in analysis routines and internal threads. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g50dac280d3e41bea9b48974231f43dab"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetStoppedThreadContext" ref="g50dac280d3e41bea9b48974231f43dab" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>* LEVEL_PINCLIENT::PIN_GetStoppedThreadContext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the CONTEXT (register state) of a stopped application thread. The caller can inspect the stopped thread's register state via <a class="el" href="group__CONTEXT__API.html#gc1358a6179f0a63300fdf34ecf8b741d">PIN_GetContextReg()</a> and related API's.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Pin ID of a stopped thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The CONTEXT for thread <em>tid</em> or NULL if that thread is not stopped.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g728fc728138b1049d1785f46cd8cd310"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetStoppedThreadCount" ref="g728fc728138b1049d1785f46cd8cd310" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::PIN_GetStoppedThreadCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function can be called in two scenarios. First, it may be called after stopping threads with <a class="el" href="group__STOPPED__THREAD__API.html#g548ed1631804b58caa91ab40970bea87">PIN_StopApplicationThreads()</a>, in which case it tells the number of application threads that were stopped with that API.<p>
Alternatively, this function may be called from a call-back that is registered via <a class="el" href="group__APPDEBUG__API.html#g57d86fbcd855d998c28e27a8dfa56643">PIN_AddDebugInterpreter()</a>. In this case, it tells the number of application threads that are stopped in the debugger.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of stopped application threads. Returns zero if threads are not currently stopped.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g117be31fa21b8be7e73d0ef8376e2d11"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetStoppedThreadId" ref="g117be31fa21b8be7e73d0ef8376e2d11" args="(UINT32 i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> LEVEL_PINCLIENT::PIN_GetStoppedThreadId           </td>
          <td>(</td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the Pin thread ID of a stopped application thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>An index in the range [0, n-1], where <em>n</em> is the value returned by <a class="el" href="group__STOPPED__THREAD__API.html#g728fc728138b1049d1785f46cd8cd310">PIN_GetStoppedThreadCount()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ID of the indexed thread, which is currently stopped. Returns INVALID_THREADID if <em>i</em> is out of range.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7154fed50af7d888d5bfd04bd70b7396"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetStoppedThreadWriteableContext" ref="g7154fed50af7d888d5bfd04bd70b7396" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>* LEVEL_PINCLIENT::PIN_GetStoppedThreadWriteableContext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is similar to <a class="el" href="group__STOPPED__THREAD__API.html#g50dac280d3e41bea9b48974231f43dab">PIN_GetStoppedThreadContext()</a>, but it returns a CONTEXT that may be modified. The caller may modify the stopped thread's register state via <a class="el" href="group__CONTEXT__API.html#g2369ec2d95122f62cb3673a5a3507023">PIN_SetContextReg()</a> and related API's. The stopped thread uses the new register state when it resumes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Pin ID of a stopped thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The CONTEXT for thread <em>tid</em> or NULL if that thread is not stopped.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb83ac31abfc4074429c4b5cde43dbca1"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsThreadStoppedInDebugger" ref="gb83ac31abfc4074429c4b5cde43dbca1" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_IsThreadStoppedInDebugger           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns true if the thread with denoted by 'tid' given by its arguments was stopped in the debugger. Note: If there is no thread with ID 'tid', this function returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID to check</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the specified thread was stopped in the debugger. FALSE indicates that the thread is either running, or doesn't exist</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3b14a74ff766a0ddf12f591d53e08d2b"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_ResumeApplicationThreads" ref="g3b14a74ff766a0ddf12f591d53e08d2b" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ResumeApplicationThreads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function may be called after a successful call to <a class="el" href="group__STOPPED__THREAD__API.html#g548ed1631804b58caa91ab40970bea87">PIN_StopApplicationThreads()</a> in order to resume execution of the stopped application threads. If a thread's CONTEXT was changed while it was stopped, it resumes with the new CONTEXT.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When used in application thread, it is highly recommended to call it in the same analysis function that called <a class="el" href="group__STOPPED__THREAD__API.html#g548ed1631804b58caa91ab40970bea87">PIN_StopApplicationThreads()</a>. Deferring the call could result in a deadlock when the thread later tries to acquire a lock held by other application thread it suspended.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the calling thread. Should be called in the same thread as corresponding <a class="el" href="group__STOPPED__THREAD__API.html#g548ed1631804b58caa91ab40970bea87">PIN_StopApplicationThreads()</a></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g548ed1631804b58caa91ab40970bea87"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StopApplicationThreads" ref="g548ed1631804b58caa91ab40970bea87" args="(THREADID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_StopApplicationThreads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function may be called by either an application thread or by a Pin internal thread to stop all other application threads at a "safe point". Threads that are stopped at a safe point are always stopped in between traces, so the caller is guaranteed that they are not stopped in the middle of any analysis functions or call-back functions. Once stopped, the calling thread can examine and modify the registers of the stopped threads.<p>
If this function is called by an internal thread, it stops all application threads. If it is called by an application thread, it stops all other application threads. When called by an application thread, this function may be called from an analysis function, but not from a call-back function.<p>
Since this function blocks until other application threads finish their current trace, the caller must not hold any locks that the other threads might try to acquire. Doing so could result in a deadlock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the calling thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the target threads are successfully stopped. FALSE indicates that some other thread is trying to stop the calling thread. In such a case, the caller should return from its analysis function to avoid a deadlock.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jan 28 23:35:32 2018 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
