<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Fast Buffering APIs</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Fast Buffering APIs</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID *(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g6075d5b3f541c6d2430c87e7d8d4a807">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a> (BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BUFFER_ID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g008bd698d07658fc4f60fd9b61fb81bc">LEVEL_PINCLIENT::PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g2c9c14f8b8dc4a6cb6c137f533d8d14a">LEVEL_PINCLIENT::PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#gd6f219bd78622a73d42d37e3f9d6801e">LEVEL_PINCLIENT::PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g2c67a48c18fcdc9c88ed826e28f40434">LEVEL_PINCLIENT::PIN_GetBufferPointer</a> (<a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
APIs to perform low-overhead buffering of data for analysis. Use <a class="el" href="group__BUFFER__API.html#g008bd698d07658fc4f60fd9b61fb81bc">PIN_DefineTraceBuffer()</a> to create space for storing data, and <a class="el" href="group__INS__INST__API.html#gcf731514b88f79344068df5d8e60eacc">INS_InsertFillBuffer()</a> to fill the buffers. When a buffer overflows, or the thread exits, the defined callback will be used to process the data. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g6075d5b3f541c6d2430c87e7d8d4a807"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK" ref="g6075d5b3f541c6d2430c87e7d8d4a807" args="(BUFFER_ID id, THREADID tid, const CONTEXT *ctxt, VOID *buf, UINT64 numElements, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID*(*) <a class="el" href="group__BUFFER__API.html#g6075d5b3f541c6d2430c87e7d8d4a807">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a>(BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A call-back function which Pin calls whenever the tools needs to consume a trace buffer (e.g., the trace buffer is full).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function may be called on a different thread than the given threadIndex.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The ID of the thread owning this buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the start of the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements collected into the buffer which need to be consumed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the buffer to use when the thread resumes. Typically, this is <em>buf</em>, but see also <a class="el" href="group__BUFFER__API.html#g2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g2c9c14f8b8dc4a6cb6c137f533d8d14a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AllocateBuffer" ref="g2c9c14f8b8dc4a6cb6c137f533d8d14a" args="(BUFFER_ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_AllocateBuffer           </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly allocate a trace buffer. This is only needed for tools which use a "double buffering" technique. When used, the buffer pointer should be returned from the TRACE_BUFFER_CALLBACK call-back.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer to allocate.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new buffer.]</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd6f219bd78622a73d42d37e3f9d6801e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DeallocateBuffer" ref="gd6f219bd78622a73d42d37e3f9d6801e" args="(BUFFER_ID id, VOID *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_DeallocateBuffer           </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly deallocate a trace buffer. This is only needed by tools using a "double buffering" technique, where it is used to deallocate buffers allocated via <a class="el" href="group__BUFFER__API.html#g2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. However, it may be safely called (with no effect) for a thread's implicit initial buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the start of the buffer.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g008bd698d07658fc4f60fd9b61fb81bc"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DefineTraceBuffer" ref="g008bd698d07658fc4f60fd9b61fb81bc" args="(size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BUFFER_ID LEVEL_PINCLIENT::PIN_DefineTraceBuffer           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>numPages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRACE_BUFFER_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a trace buffer to use with the Pin trace buffer API. This function defines the shape of the buffer, but doesn't allocate the buffer itself. Each thread implicitly creates its first buffer on start-up. Additional buffers may then be created using <a class="el" href="group__BUFFER__API.html#g2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer</a>, but this is only needed by tools using "double buffering".<p>
Upon exit, the notification callback may be called on a different physical thread than the one that is exiting.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recordSize</em>&nbsp;</td><td>Size (bytes) of each record in the buffer. This size must be less than the size of an OS page. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numPages</em>&nbsp;</td><td>The number of OS pages to allocate for each buffer. This size does not have to be an even multiple of <em>recordSize</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>A call-back function that is called whenever the buffer is full, or when the thread exits with a partially-full buffer. Note that when called for a full buffer, not during thread exit, this function is called WITHOUT holding any Pin locks. So that multiple threads may be executing the function simultaneously. It is the tool's responsibility to take care of the multi-thread safety of this function, and any functions called by it. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Passed as the last argument to <em>fun</em>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, a BUFFER_ID. On error (e.g., maximum number of trace buffers exceeded,) returns BUFFER_ID_INVALID.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2c67a48c18fcdc9c88ed826e28f40434"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetBufferPointer" ref="g2c67a48c18fcdc9c88ed826e28f40434" args="(CONTEXT *const ctxt, BUFFER_ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_GetBufferPointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const&nbsp;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the address of the current position in the buffer. Needs a CONTEXT that was passed in as a call back argument or IARG_CONTEXT<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>CONTEXT</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jan 28 23:35:32 2018 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
