<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Instrumentation arguments</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Instrumentation arguments</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPIN__MEM__ACCESS__INFO.html">PIN_MEM_ACCESS_INFO</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPIN__MULTI__MEM__ACCESS__INFO.html">PIN_MULTI_MEM_ACCESS_INFO</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPIN__MEM__TRANS__FLAGS.html">PIN_MEM_TRANS_FLAGS</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g5d3025eb005b7ea4745799f0ee1b86a6">PIN_FAST_ANALYSIS_CALL</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef IARGLIST_CLASS *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> { <br>
&nbsp;&nbsp;<b>IPOINT_INVALID</b>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad742eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad7cf7dee2063098dd79907d19f9c7df65d">IPOINT_ANYWHERE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad75ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg3d1d5f6805cb16d00bce441290ca22123f53c3878be5c2859b82b540561b72b3">CALL_ORDER_FIRST</a> =  100, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg3d1d5f6805cb16d00bce441290ca221243af3c7aa24c81dddf629b2828b8354c">CALL_ORDER_DEFAULT</a> =  200, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg3d1d5f6805cb16d00bce441290ca22120b197a15a2399e6443ce6be187ccf6c6">CALL_ORDER_LAST</a> =  300
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a> { <br>
&nbsp;&nbsp;<b>IARG_INVALID</b>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d34126f334d65afac69784351a03615ad">IARG_ADDRINT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dcac3cb99011b351eeb3f675bc8c62b83">IARG_BOOL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd">IARG_UINT32</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451db2d3f91c48319ea5e824fdc678ae4a5c">IARG_UINT64</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dbe70796bf61230dac3ea1deaf4983c46">IARG_REG_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d817f3f2fe8c0c536daa86deb55126c25">IARG_REG_CONST_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2138787daf04a57e6684eb0b368e120e">IARG_MEMORYREAD_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2931627e96b437dc55e06966d31ad962">IARG_MEMORYREAD2_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d92be352ec619bbd3be69fed773c011a2">IARG_MEMORYWRITE_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd2e2d24103d1a0286b57412f66b909d7">IARG_MEMORYREAD_SIZE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d365d8eed26ac239b013a01ab6a7cf375">IARG_MEMORYWRITE_SIZE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d4b127f5e8c89aabe67abb6d04ee8ecce">IARG_MEMORYREAD_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d96d283a176b568500d63a7b8ad2558ed">IARG_MEMORYREAD2_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d9fead51aa9d72879eadd61ae5cb00e98">IARG_MEMORYWRITE_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d52ab7563efadafe484b53421e42ec8b1">IARG_MEMORYOP_PTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da60ade75a81b448320631155e84829a6">IARG_MULTI_MEMORYACCESS_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d87c9a713268fea1c9ddb157aa0a475eb">IARG_EXPLICIT_MEMORY_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47">IARG_BRANCH_TAKEN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da1b650f4229df434f3ac5ef61f14d0ed">IARG_BRANCH_TARGET_ADDR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0faf9829bd4f46cc1873c943978b21d7">IARG_FALLTHROUGH_ADDR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d5f291cb55a7d61a40fa3ab98e191394e">IARG_EXECUTING</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d4e8c634973d6966dba21ff70455c1f5b">IARG_FIRST_REP_ITERATION</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d8cbb1c02c9e1bad259570179580adb50">IARG_PREDICATE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dcd300aa37115a80c4ce30e11e7a37846">IARG_STACK_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0ea57a2ba5c26fe0b0e7d75a8de06fee">IARG_STACK_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2b71d3e92a6b768857bd60cd1ffb67bb">IARG_MEMORY_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd99d33d82bec02d9dc8c1639c90920a2">IARG_MEMORY_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d6e903286d783f6ee402e146b8dff871f">IARG_SYSCALL_NUMBER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dcf2d3d2c61544c89918563331a73b2f4">IARG_SYSARG_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d53b9c85f47960f7b805dc0bb8b6a1a2e">IARG_SYSARG_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0480757dd8ff829a67621df1e9e5396d">IARG_SYSRET_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d969a0228ddab7219f20426504991b676">IARG_SYSRET_ERRNO</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d4babc2672f5a58d94f8fb8f5234c14d4">IARG_FUNCARG_CALLSITE_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d8766561ec59dfb16a94edb3624f53ab8">IARG_FUNCARG_CALLSITE_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451db23dff2bab780c074d4998d14f4ecb16">IARG_FUNCARG_ENTRYPOINT_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451db418d242314ea7c67b1febf7667e93a1">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d78065c99b8462ff353115dc9f6419931">IARG_FUNCRET_EXITPOINT_REFERENCE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d19dc8d3703330b7b1e1064336dd235cf">IARG_FUNCRET_EXITPOINT_VALUE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2c4a6ff4e8a076e0f39d24ab73ec7092">IARG_RETURN_IP</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd12677dad18848be51b49ea0f48e07cb">IARG_PROTOTYPE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451de11c26daf8993e626359a566d35d46d0">IARG_IARGLIST</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d892dbdf11883df94c327bb31fd0d5fcd">IARG_FAST_ANALYSIS_CALL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d985747a3c70e3a4283fc8a2f16399e63">IARG_MEMORYOP_EA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d821b74fed6ac3d8740d73245b4f26a06">IARG_MEMORYOP_MASKED_ON</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d30acbbeded5e7e293324f81cc796ef7d">IARG_TSC</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2d2d4502ddc8de6d717c6878101c73df">IARG_FILE_NAME</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d5a86209c9f24bebb204f1c435eb18d1c">IARG_LINE_NO</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd1fd7d0ac8f175d5340787ff3f3a2093">IARG_LAST</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g624ddd00f45938da5eb525afc5b43195">PIN_MEMOP_ENUM</a> { <br>
&nbsp;&nbsp;<b>PIN_MEMOP_LOAD</b>, 
<br>
&nbsp;&nbsp;<b>PIN_MEMOP_STORE</b>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ge3eb88acf12be3a154102006b4de7e4d">LEVEL_PINCLIENT::IARGLIST_AddArguments</a> (<a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> args,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g5cbcceec6b0a3ebe21b78c85c4a8c8c9">LEVEL_PINCLIENT::IARGLIST_Alloc</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#g392b26a0d0881f24d3abf7d4d1d8e176">LEVEL_PINCLIENT::IARGLIST_Free</a> (<a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> args)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g877f94fac7240569d9a9de91f91ef5a7"></a><!-- doxytag: member="INST_ARGS::MAX_MULTI_MEMOPS" ref="g877f94fac7240569d9a9de91f91ef5a7" args="" -->
GLOBALCONST int&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAX_MULTI_MEMOPS</b> = 16</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
See INS_InsertCall.<h2><a class="anchor" name="SEC_IARG_END">
IARG_END</a></h2>
All argument lists must end with IARG_END. Please see the <a class="el" href="index.html#EXAMPLES">Examples</a> for further information.<h2><a class="anchor" name="PROBE_IARGS">
Probe Mode Considerations</a></h2>
When IARG_CONTEXT is used in probe mode, it is impossible to get certain register values correct. The values in these registers are meaningless when IARG_CONTEXT is used in probe mode:<p>
REG_SEG_GS_BASE <br>
 REG_SEG_FS_BASE <br>
 REG_INST_G0 - REG_INST_G19 <br>
<p>
Using <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> and <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> is not supported in Probe mode.<h2><a class="anchor" name="NO_INLINE_IARGS">
Inlining Considerations</a></h2>
The <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> and <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> IARG_TYPE cannot be inlined. Using these CONTEXT IARG_TYPE will prevent the analysis routine from being inlined. <hr><h2>Define Documentation</h2>
<a class="anchor" name="g5d3025eb005b7ea4745799f0ee1b86a6"></a><!-- doxytag: member="types_vmapi.H::PIN_FAST_ANALYSIS_CALL" ref="g5d3025eb005b7ea4745799f0ee1b86a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIN_FAST_ANALYSIS_CALL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use a faster linkage for calls to analysis functions. Add PIN_FAST_ANALYSIS_CALL to the declaration between the return type and the function name. You must also add <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d892dbdf11883df94c327bb31fd0d5fcd">IARG_FAST_ANALYSIS_CALL</a> to the InsertCall. For example:<p>
VOID PIN_FAST_ANALYSIS_CALL docount(int j);<p>
INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, 3, IARG_END); <p>
You will gain the most benefit from using PIN_FAST_ANALYSIS_CALL if<ul>
<li>you are instrumenting a 32 bit process (the 64 bit calling conventions already pass arguments in registers)</li><li>your analysis routine is not inlined (if it is inlined there is no call to optimize)</li><li>your analysis routine is relatively small (if it is large the extra overhead imposed by the poor calling convention won't be significant anyway) </li></ul>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gfbeb707dc23c7c09e1e8c932649107d5"></a><!-- doxytag: member="types_vmapi.H::IARGLIST" ref="gfbeb707dc23c7c09e1e8c932649107d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IARGLIST_CLASS* <a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of IARG_TYPE elements. See <a class="el" href="group__INST__ARGS.html#g5cbcceec6b0a3ebe21b78c85c4a8c8c9">IARGLIST_Alloc()</a> for its use. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g3d1d5f6805cb16d00bce441290ca2212"></a><!-- doxytag: member="types_vmapi.H::CALL_ORDER" ref="g3d1d5f6805cb16d00bce441290ca2212" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Predefined values for <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. Controls the order of analysis call invocations when an instruction has multiple analysis calls. CALL_ORDER_DEFAULT is the default call order when <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a> is not specified. You can use integral values relative to the predefined values to have a fine-grained control over the instrumentation order (e.g., CALL_ORDER_DEFAULT + 5, CALL_ORDER_LAST - 10, etc).<p>
Pin guarantees that multiple analysis calls with the same CALL_ORDER on the same instruction, added in the context of the same instrumentation callback (e.g,. <a class="el" href="group__INS__INST__API.html#INS_INSTRUMENT_CALLBACK">INS_INSTRUMENT_CALLBACK</a>), will be invoked according to their insertion order. For all other cases, the invocation order for analysis calls with the same CALL_ORDER on the same instruction depends on the implementation and may change without notice. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg3d1d5f6805cb16d00bce441290ca22123f53c3878be5c2859b82b540561b72b3"></a><!-- doxytag: member="CALL_ORDER_FIRST" ref="gg3d1d5f6805cb16d00bce441290ca22123f53c3878be5c2859b82b540561b72b3" args="" -->CALL_ORDER_FIRST</em>&nbsp;</td><td>
Execute this call first. Value is 100. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3d1d5f6805cb16d00bce441290ca221243af3c7aa24c81dddf629b2828b8354c"></a><!-- doxytag: member="CALL_ORDER_DEFAULT" ref="gg3d1d5f6805cb16d00bce441290ca221243af3c7aa24c81dddf629b2828b8354c" args="" -->CALL_ORDER_DEFAULT</em>&nbsp;</td><td>
Default when IARG_CALL_ORDER is not specified. Value is 200. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg3d1d5f6805cb16d00bce441290ca22120b197a15a2399e6443ce6be187ccf6c6"></a><!-- doxytag: member="CALL_ORDER_LAST" ref="gg3d1d5f6805cb16d00bce441290ca22120b197a15a2399e6443ce6be187ccf6c6" args="" -->CALL_ORDER_LAST</em>&nbsp;</td><td>
Execute this call last. Value is 300. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g089c27ca15e9ff139dd3a3f8a6f8451d"></a><!-- doxytag: member="types_vmapi.H::IARG_TYPE" ref="g089c27ca15e9ff139dd3a3f8a6f8451d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the arguments that are passed to the analysis call. All argument lists must end with IARG_END. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d34126f334d65afac69784351a03615ad"></a><!-- doxytag: member="IARG_ADDRINT" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d34126f334d65afac69784351a03615ad" args="" -->IARG_ADDRINT</em>&nbsp;</td><td>
Type: ADDRINT. Constant value (additional arg required). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b"></a><!-- doxytag: member="IARG_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b" args="" -->IARG_PTR</em>&nbsp;</td><td>
Type: "VOID *". Constant value (additional pointer arg required). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dcac3cb99011b351eeb3f675bc8c62b83"></a><!-- doxytag: member="IARG_BOOL" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dcac3cb99011b351eeb3f675bc8c62b83" args="" -->IARG_BOOL</em>&nbsp;</td><td>
Type: BOOL. Constant (additional BOOL arg required). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd"></a><!-- doxytag: member="IARG_UINT32" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd" args="" -->IARG_UINT32</em>&nbsp;</td><td>
Type: UINT32. Constant (additional integer arg required). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451db2d3f91c48319ea5e824fdc678ae4a5c"></a><!-- doxytag: member="IARG_UINT64" ref="gg089c27ca15e9ff139dd3a3f8a6f8451db2d3f91c48319ea5e824fdc678ae4a5c" args="" -->IARG_UINT64</em>&nbsp;</td><td>
Type: UINT64. Constant (additional UINT64 arg required). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a"></a><!-- doxytag: member="IARG_INST_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a" args="" -->IARG_INST_PTR</em>&nbsp;</td><td>
Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER. This is simply shorthand for <code>IARG_ADDRINT, INS_Address(ins)</code>. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dbe70796bf61230dac3ea1deaf4983c46"></a><!-- doxytag: member="IARG_REG_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dbe70796bf61230dac3ea1deaf4983c46" args="" -->IARG_REG_VALUE</em>&nbsp;</td><td>
Type: ADDRINT for integer registers. Value of a register (additional register arg required) <a class="el" href="group__REG__BASIC__API.html">REG: Register Object</a> Basically, this cannot be used to retrieve the value of registers whose size is larger than ADDRINT (e.g. x87 FPU/XMM/YMM/ZMM/opmask) or registeres which are not architectural (REG_PIN_*), but there are some exceptions to this rule. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d0337fbb99845733a3d35a9a3dbcfbf93"></a><!-- doxytag: member="IARG_REG_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d0337fbb99845733a3d35a9a3dbcfbf93" args="" -->IARG_REG_REFERENCE</em>&nbsp;</td><td>
Type: "@ref PIN_REGISTER *". Pointer to union holding register contents. Registers are updated. Not supported in Probe mode or with the Buffering APIs. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d817f3f2fe8c0c536daa86deb55126c25"></a><!-- doxytag: member="IARG_REG_CONST_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d817f3f2fe8c0c536daa86deb55126c25" args="" -->IARG_REG_CONST_REFERENCE</em>&nbsp;</td><td>
Type: "@ref PIN_REGISTER *". Pointer to union holding register contents. Registers are not updated. Not supported with the Buffering APIs. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d2138787daf04a57e6684eb0b368e120e"></a><!-- doxytag: member="IARG_MEMORYREAD_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d2138787daf04a57e6684eb0b368e120e" args="" -->IARG_MEMORYREAD_EA</em>&nbsp;</td><td>
Type: ADDRINT. Effective address of a memory read, only valid if INS_IsMemoryRead is true and at IPOINT_BEFORE. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d2931627e96b437dc55e06966d31ad962"></a><!-- doxytag: member="IARG_MEMORYREAD2_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d2931627e96b437dc55e06966d31ad962" args="" -->IARG_MEMORYREAD2_EA</em>&nbsp;</td><td>
Type: ADDRINT. Effective address of a 2nd memory read (e.g. 2nd operand in cmps on ia32), only valid at IPOINT_BEFORE. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d92be352ec619bbd3be69fed773c011a2"></a><!-- doxytag: member="IARG_MEMORYWRITE_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d92be352ec619bbd3be69fed773c011a2" args="" -->IARG_MEMORYWRITE_EA</em>&nbsp;</td><td>
Type: ADDRINT. Effective address of a memory write, only valid at IPOINT_BEFORE. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dd2e2d24103d1a0286b57412f66b909d7"></a><!-- doxytag: member="IARG_MEMORYREAD_SIZE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dd2e2d24103d1a0286b57412f66b909d7" args="" -->IARG_MEMORYREAD_SIZE</em>&nbsp;</td><td>
Type: UINT32. Size in bytes of memory read. This IARG is applicable for all instructions for which INS_hasKnownMemorySize returns TRUE. For other instructions e.g. vgather/vscater see <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da60ade75a81b448320631155e84829a6">IARG_MULTI_MEMORYACCESS_EA</a>. For the varying memory size read instruction, XRSTOR, the size is based on the XSAVE area header. If the header indicates compact mode it will provide the compact size. Otherwise it will provide the standard size. The minimum size for the XRSTOR instruction (not including FXRSTOR) is 576 (i.e the XSAVE area size up to and including the header). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d365d8eed26ac239b013a01ab6a7cf375"></a><!-- doxytag: member="IARG_MEMORYWRITE_SIZE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d365d8eed26ac239b013a01ab6a7cf375" args="" -->IARG_MEMORYWRITE_SIZE</em>&nbsp;</td><td>
Type: UINT32. Size in bytes of memory write. This IARG is applicable for all instructions for which INS_hasKnownMemorySize returns TRUE. For other instructions e.g. vgather/vscater see <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da60ade75a81b448320631155e84829a6">IARG_MULTI_MEMORYACCESS_EA</a>. For varying size memory write instructions, the supported instructions are the XSAVE family of instructions. For XSAVE, the size of the XSAVE area used is based on user request and supported features in the machine. This will provide the exact size used. For XSAVEOPT, the size is calculated the same as if XSAVE was used. This may provide in some cases an upper bound to the actual used memory. For XSAVEC, in IPOINT_BEFORE the size is calculated based on user request only. This may provide in some cases an upper bound to the actual size. If used in IPOINT_AFTER it will provide the exact compact size as defined in the XSAVE area header. The minimum size for the XSAVE family write instructions (not including FXSAVE) is 576 (i.e the XSAVE area size up to and including the header). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d4b127f5e8c89aabe67abb6d04ee8ecce"></a><!-- doxytag: member="IARG_MEMORYREAD_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d4b127f5e8c89aabe67abb6d04ee8ecce" args="" -->IARG_MEMORYREAD_PTR</em>&nbsp;</td><td>
Actual address of the memory access; same as <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2138787daf04a57e6684eb0b368e120e">IARG_MEMORYREAD_EA</a>, unless the memory address is translated by MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by INS_RewriteMemoryOperand </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d96d283a176b568500d63a7b8ad2558ed"></a><!-- doxytag: member="IARG_MEMORYREAD2_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d96d283a176b568500d63a7b8ad2558ed" args="" -->IARG_MEMORYREAD2_PTR</em>&nbsp;</td><td>
Actual address of the memory access; same as <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2931627e96b437dc55e06966d31ad962">IARG_MEMORYREAD2_EA</a>, unless the memory address is translated by MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by INS_RewriteMemoryOperand </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d9fead51aa9d72879eadd61ae5cb00e98"></a><!-- doxytag: member="IARG_MEMORYWRITE_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d9fead51aa9d72879eadd61ae5cb00e98" args="" -->IARG_MEMORYWRITE_PTR</em>&nbsp;</td><td>
Actual address of the memory access. Same as <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d92be352ec619bbd3be69fed773c011a2">IARG_MEMORYWRITE_EA</a>, unless the memory address is translated by MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by INS_RewriteMemoryOperand </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d52ab7563efadafe484b53421e42ec8b1"></a><!-- doxytag: member="IARG_MEMORYOP_PTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d52ab7563efadafe484b53421e42ec8b1" args="" -->IARG_MEMORYOP_PTR</em>&nbsp;</td><td>
Actual address of the memory access. Same as <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d985747a3c70e3a4283fc8a2f16399e63">IARG_MEMORYOP_EA</a>, unless the memory address is translated by MEMORY_ADDR_TRANS_CALLBACK, or the memory operand is rewritten by INS_RewriteMemoryOperand </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451da60ade75a81b448320631155e84829a6"></a><!-- doxytag: member="IARG_MULTI_MEMORYACCESS_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451da60ade75a81b448320631155e84829a6" args="" -->IARG_MULTI_MEMORYACCESS_EA</em>&nbsp;</td><td>
Type: PIN_MULTI_MEM_ACCESS_INFO* the addresses read by the various vgather* instructions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d87c9a713268fea1c9ddb157aa0a475eb"></a><!-- doxytag: member="IARG_EXPLICIT_MEMORY_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d87c9a713268fea1c9ddb157aa0a475eb" args="" -->IARG_EXPLICIT_MEMORY_EA</em>&nbsp;</td><td>
Type: ADDRINT. Effective address of the explicit memory operand. Useful for instrumenting LEA instructions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47"></a><!-- doxytag: member="IARG_BRANCH_TAKEN" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47" args="" -->IARG_BRANCH_TAKEN</em>&nbsp;</td><td>
Type: BOOL. Non zero if a branch is taken. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451da1b650f4229df434f3ac5ef61f14d0ed"></a><!-- doxytag: member="IARG_BRANCH_TARGET_ADDR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451da1b650f4229df434f3ac5ef61f14d0ed" args="" -->IARG_BRANCH_TARGET_ADDR</em>&nbsp;</td><td>
Type: ADDRINT. Target address of this branch instruction, only valid if INS_IsBranchOrCall is true. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d0faf9829bd4f46cc1873c943978b21d7"></a><!-- doxytag: member="IARG_FALLTHROUGH_ADDR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d0faf9829bd4f46cc1873c943978b21d7" args="" -->IARG_FALLTHROUGH_ADDR</em>&nbsp;</td><td>
Type: ADDRINT. Fall through address of this instruction. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d5f291cb55a7d61a40fa3ab98e191394e"></a><!-- doxytag: member="IARG_EXECUTING" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d5f291cb55a7d61a40fa3ab98e191394e" args="" -->IARG_EXECUTING</em>&nbsp;</td><td>
Type: BOOL. False if the instruction will not be executed because of predication, otherwise true. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d4e8c634973d6966dba21ff70455c1f5b"></a><!-- doxytag: member="IARG_FIRST_REP_ITERATION" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d4e8c634973d6966dba21ff70455c1f5b" args="" -->IARG_FIRST_REP_ITERATION</em>&nbsp;</td><td>
Type: BOOL. True if INS_HasRealRep(ins) and this the first iteration of the REP sequence, otherwise false. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d8cbb1c02c9e1bad259570179580adb50"></a><!-- doxytag: member="IARG_PREDICATE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d8cbb1c02c9e1bad259570179580adb50" args="" -->IARG_PREDICATE</em>&nbsp;</td><td>
Reserved. Do not use. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dcd300aa37115a80c4ce30e11e7a37846"></a><!-- doxytag: member="IARG_STACK_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dcd300aa37115a80c4ce30e11e7a37846" args="" -->IARG_STACK_VALUE</em>&nbsp;</td><td>
Reserved. Do not use. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d0ea57a2ba5c26fe0b0e7d75a8de06fee"></a><!-- doxytag: member="IARG_STACK_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d0ea57a2ba5c26fe0b0e7d75a8de06fee" args="" -->IARG_STACK_REFERENCE</em>&nbsp;</td><td>
Reserved. Do not use. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d2b71d3e92a6b768857bd60cd1ffb67bb"></a><!-- doxytag: member="IARG_MEMORY_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d2b71d3e92a6b768857bd60cd1ffb67bb" args="" -->IARG_MEMORY_VALUE</em>&nbsp;</td><td>
Reserved. IA32(e) only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dd99d33d82bec02d9dc8c1639c90920a2"></a><!-- doxytag: member="IARG_MEMORY_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dd99d33d82bec02d9dc8c1639c90920a2" args="" -->IARG_MEMORY_REFERENCE</em>&nbsp;</td><td>
Reserved. IA32(e) only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d6e903286d783f6ee402e146b8dff871f"></a><!-- doxytag: member="IARG_SYSCALL_NUMBER" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d6e903286d783f6ee402e146b8dff871f" args="" -->IARG_SYSCALL_NUMBER</em>&nbsp;</td><td>
Type: ADDRINT. System call number. Valid for IPOINT_BEFORE at the system call instruction. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dcf2d3d2c61544c89918563331a73b2f4"></a><!-- doxytag: member="IARG_SYSARG_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dcf2d3d2c61544c89918563331a73b2f4" args="" -->IARG_SYSARG_REFERENCE</em>&nbsp;</td><td>
Type: "ADDRINT *". Pointer to system call argument n. Valid for IPOINT_BEFORE at the system call instruction. (First argument number is 0.). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d53b9c85f47960f7b805dc0bb8b6a1a2e"></a><!-- doxytag: member="IARG_SYSARG_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d53b9c85f47960f7b805dc0bb8b6a1a2e" args="" -->IARG_SYSARG_VALUE</em>&nbsp;</td><td>
Type: ADDRINT. System call argument n. Valid for IPOINT_BEFORE at the system call instruction. (First argument number is 0.). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d0480757dd8ff829a67621df1e9e5396d"></a><!-- doxytag: member="IARG_SYSRET_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d0480757dd8ff829a67621df1e9e5396d" args="" -->IARG_SYSRET_VALUE</em>&nbsp;</td><td>
Type: ADDRINT. System call return value. On Linux and MacOS the value is -1 if the system call failed. (IPOINT_AFTER only). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d969a0228ddab7219f20426504991b676"></a><!-- doxytag: member="IARG_SYSRET_ERRNO" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d969a0228ddab7219f20426504991b676" args="" -->IARG_SYSRET_ERRNO</em>&nbsp;</td><td>
Type: INT32. System call errno (IPOINT_AFTER_only). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d4babc2672f5a58d94f8fb8f5234c14d4"></a><!-- doxytag: member="IARG_FUNCARG_CALLSITE_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d4babc2672f5a58d94f8fb8f5234c14d4" args="" -->IARG_FUNCARG_CALLSITE_REFERENCE</em>&nbsp;</td><td>
Type: "ADDRINT *". Pointer to integer argument n. Valid only at the call site. (First argument number is 0.) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d8766561ec59dfb16a94edb3624f53ab8"></a><!-- doxytag: member="IARG_FUNCARG_CALLSITE_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d8766561ec59dfb16a94edb3624f53ab8" args="" -->IARG_FUNCARG_CALLSITE_VALUE</em>&nbsp;</td><td>
Type: ADDRINT. Integer argument n. Valid only at the call site. (First argument number is 0.) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451db23dff2bab780c074d4998d14f4ecb16"></a><!-- doxytag: member="IARG_FUNCARG_ENTRYPOINT_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451db23dff2bab780c074d4998d14f4ecb16" args="" -->IARG_FUNCARG_ENTRYPOINT_REFERENCE</em>&nbsp;</td><td>
Type: "ADDRINT *". Pointer to integer argument n. Valid only at the entry point of a routine. (First argument number is 0.) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451db418d242314ea7c67b1febf7667e93a1"></a><!-- doxytag: member="IARG_FUNCARG_ENTRYPOINT_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451db418d242314ea7c67b1febf7667e93a1" args="" -->IARG_FUNCARG_ENTRYPOINT_VALUE</em>&nbsp;</td><td>
Type: ADDRINT. Integer argument n. Valid only at the entry point of a routine. (First argument number is 0.) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d78065c99b8462ff353115dc9f6419931"></a><!-- doxytag: member="IARG_FUNCRET_EXITPOINT_REFERENCE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d78065c99b8462ff353115dc9f6419931" args="" -->IARG_FUNCRET_EXITPOINT_REFERENCE</em>&nbsp;</td><td>
Type: "ADDRINT *". Pointer to function result. Valid only at return instruction. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d19dc8d3703330b7b1e1064336dd235cf"></a><!-- doxytag: member="IARG_FUNCRET_EXITPOINT_VALUE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d19dc8d3703330b7b1e1064336dd235cf" args="" -->IARG_FUNCRET_EXITPOINT_VALUE</em>&nbsp;</td><td>
Type: ADDRINT. Function result. Valid only at return instruction. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d2c4a6ff4e8a076e0f39d24ab73ec7092"></a><!-- doxytag: member="IARG_RETURN_IP" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d2c4a6ff4e8a076e0f39d24ab73ec7092" args="" -->IARG_RETURN_IP</em>&nbsp;</td><td>
Type: ADDRINT. Return address for function call, valid only at the function entry point. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d0425900c8991df5d840dd6d9f9b03295"></a><!-- doxytag: member="IARG_ORIG_FUNCPTR" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d0425900c8991df5d840dd6d9f9b03295" args="" -->IARG_ORIG_FUNCPTR</em>&nbsp;</td><td>
Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dd12677dad18848be51b49ea0f48e07cb"></a><!-- doxytag: member="IARG_PROTOTYPE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dd12677dad18848be51b49ea0f48e07cb" args="" -->IARG_PROTOTYPE</em>&nbsp;</td><td>
Type: PROTO. The function prototype of the application function. See <a class="el" href="group__PROTO.html">Prototypes</a>. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4"></a><!-- doxytag: member="IARG_THREAD_ID" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4" args="" -->IARG_THREAD_ID</em>&nbsp;</td><td>
Type: THREADID. Application thread id. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d"></a><!-- doxytag: member="IARG_CONTEXT" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d" args="" -->IARG_CONTEXT</em>&nbsp;</td><td>
Type: <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *. Handle to access a context (architectural state). When passed at <a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad742eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a> or <a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad75ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a>, PC points to the next instruction. Upon return from the analysis routine, Pin ignores any changes you've made to the <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>. If you want to change register values, use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, or PIN_ExecuteAt. See <a class="el" href="group__INST__ARGS.html#PROBE_IARGS">Probe Mode Considerations</a> for probe mode restrictions. Not supported with the Buffering APIs. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45"></a><!-- doxytag: member="IARG_CONST_CONTEXT" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45" args="" -->IARG_CONST_CONTEXT</em>&nbsp;</td><td>
Type: <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *. Like <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, but tool receives a read-only <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>*. PIN_SetContextReg, PIN_SetContextRegval and PIN_SetContextFPState will not work with <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. The overhead of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> is considerably lower than that of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. Tools that need a <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>* and only read from it should use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. Tools that need a <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a>* and only occasionally write into it should also use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. One example of a tool that needs a <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> * and only occasionally writes into it, would be an emulator that would need to write into the <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> * only when an exception occurs, and then raise an exception with the <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *. PIN_SaveContext can be used by the tool to get a writable copy of the <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *. <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> is available only in Jit mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29"></a><!-- doxytag: member="IARG_PARTIAL_CONTEXT" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29" args="" -->IARG_PARTIAL_CONTEXT</em>&nbsp;</td><td>
Type: <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *. Additional two REGSET * arguments are needed 'inSet' and 'outSet'. Like <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, but tool needs to define also which registers set it needs to read (inSet) and which registers set it may write (outSet). PIN_SetContextReg, PIN_SetContextRegval and PIN_SetContextFPState will work only on registers that are in the outSet. These functions will change the actual application registers so there is no need to perform PIN_ExecuteAt as need to be done with <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. PIN_GetContextReg, PIN_GetContextRegval and PIN_GetContextFPState will return unexpected values for registers not defined in the 'inSet'. The overhead of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> may lower than that of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a> as there is no need to perform PIN_ExecuteAt to update registers. Tools that know which application registers are needed to be read should use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> instead of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. Thus may reduce the overhead as not fully updated context for read need to be provided. Tools that know which application registers other than REG_INST_PTR should use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> instead of combination of <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a> and the use of PIN_ExecuteAt for registers update. If REG_INST_PTR needs to be updated PIN_ExecuteAt still needs to be used. Any updates to a register from the inSet of an <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> will be propagated to the application upon return from the analysis routine. Tools that want to update <a class="el" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> registers without affecting application registers should use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dfbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> is available only in Jit mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8"></a><!-- doxytag: member="IARG_PRESERVE" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8" args="" -->IARG_PRESERVE</em>&nbsp;</td><td>
Type: REGSET *. Used to specify registers whose values will be the same upon return from the analysis routine. Should be used to specify caller-saved registers which are preserved by the analysis routine. When a non-inlinable analysis routine preserves caller-saved registers, Pin can avoid generating code to preserve these registers, across the analysis call, if they are specified in the IARG_PRESERVE. e.g. if a non-inlinable analysis routine preserves the values in the x87 registers, then Pin can avoid generating code to preserve these registers, across the analysis call, if REG_X87 is specified in the <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> e.g. if a non-inlinable analysis routine preserves the values in XMM caller saved registers, then Pin can avoid generating code to preserve these registers, across the analysis call, if those preserved XMM registers are specified in the <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> must be followed by a REGSET* that points to the REGSET containing the registers preserved. See the (REGSET_*) functions defined under <a class="el" href="group__REG__CPU__IA32.html">REG (specific to the IA-32 and Intel(R) 64 architectures)</a> for REGSET construction and manipulation. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d6c8569ef37241134ffc6e24593275981"></a><!-- doxytag: member="IARG_RETURN_REGS" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d6c8569ef37241134ffc6e24593275981" args="" -->IARG_RETURN_REGS</em>&nbsp;</td><td>
Register to write analysis function return value (additional register arg required). Not supported in Probe mode. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6"></a><!-- doxytag: member="IARG_CALL_ORDER" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6" args="" -->IARG_CALL_ORDER</em>&nbsp;</td><td>
Type: CALL_ORDER. Determine order of analysis calls. See <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451de11c26daf8993e626359a566d35d46d0"></a><!-- doxytag: member="IARG_IARGLIST" ref="gg089c27ca15e9ff139dd3a3f8a6f8451de11c26daf8993e626359a566d35d46d0" args="" -->IARG_IARGLIST</em>&nbsp;</td><td>
Type: IARGLIST. List of IARGS which can be constructed one IARG at a time. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d892dbdf11883df94c327bb31fd0d5fcd"></a><!-- doxytag: member="IARG_FAST_ANALYSIS_CALL" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d892dbdf11883df94c327bb31fd0d5fcd" args="" -->IARG_FAST_ANALYSIS_CALL</em>&nbsp;</td><td>
No type: Use a fast linkage to call the analysis function. See <a class="el" href="group__INST__ARGS.html#g5d3025eb005b7ea4745799f0ee1b86a6">PIN_FAST_ANALYSIS_CALL</a>. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d985747a3c70e3a4283fc8a2f16399e63"></a><!-- doxytag: member="IARG_MEMORYOP_EA" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d985747a3c70e3a4283fc8a2f16399e63" args="" -->IARG_MEMORYOP_EA</em>&nbsp;</td><td>
Type: ADDRINT. Effective address of a memory op (memory op index is next arg); only valid at IPOINT_BEFORE. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d821b74fed6ac3d8740d73245b4f26a06"></a><!-- doxytag: member="IARG_MEMORYOP_MASKED_ON" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d821b74fed6ac3d8740d73245b4f26a06" args="" -->IARG_MEMORYOP_MASKED_ON</em>&nbsp;</td><td>
Type: BOOL. TRUE if the this memory op (memory op index is next arg) is masked on; only valid at IPOINT_BEFORE. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d30acbbeded5e7e293324f81cc796ef7d"></a><!-- doxytag: member="IARG_TSC" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d30acbbeded5e7e293324f81cc796ef7d" args="" -->IARG_TSC</em>&nbsp;</td><td>
Type: UINT64. Time Stamp Counter value at the point of entering the analysis call. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d2d2d4502ddc8de6d717c6878101c73df"></a><!-- doxytag: member="IARG_FILE_NAME" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d2d2d4502ddc8de6d717c6878101c73df" args="" -->IARG_FILE_NAME</em>&nbsp;</td><td>
Reserved for internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451d5a86209c9f24bebb204f1c435eb18d1c"></a><!-- doxytag: member="IARG_LINE_NO" ref="gg089c27ca15e9ff139dd3a3f8a6f8451d5a86209c9f24bebb204f1c435eb18d1c" args="" -->IARG_LINE_NO</em>&nbsp;</td><td>
Reserved for internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg089c27ca15e9ff139dd3a3f8a6f8451dd1fd7d0ac8f175d5340787ff3f3a2093"></a><!-- doxytag: member="IARG_LAST" ref="gg089c27ca15e9ff139dd3a3f8a6f8451dd1fd7d0ac8f175d5340787ff3f3a2093" args="" -->IARG_LAST</em>&nbsp;</td><td>
Reserved for internal use only. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g707ea08e31f44f4a81e2a7766123bad7"></a><!-- doxytag: member="types_vmapi.H::IPOINT" ref="g707ea08e31f44f4a81e2a7766123bad7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines where the analysis call is inserted relative to the instrumented object <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20"></a><!-- doxytag: member="IPOINT_BEFORE" ref="gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20" args="" -->IPOINT_BEFORE</em>&nbsp;</td><td>
Insert a call before an instruction or routine. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg707ea08e31f44f4a81e2a7766123bad742eff26179c6d87348abe492301c12ec"></a><!-- doxytag: member="IPOINT_AFTER" ref="gg707ea08e31f44f4a81e2a7766123bad742eff26179c6d87348abe492301c12ec" args="" -->IPOINT_AFTER</em>&nbsp;</td><td>
Insert a call on the fall through path of an instruction or return path of a routine. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg707ea08e31f44f4a81e2a7766123bad7cf7dee2063098dd79907d19f9c7df65d"></a><!-- doxytag: member="IPOINT_ANYWHERE" ref="gg707ea08e31f44f4a81e2a7766123bad7cf7dee2063098dd79907d19f9c7df65d" args="" -->IPOINT_ANYWHERE</em>&nbsp;</td><td>
Insert a call anywhere inside a trace or a bbl. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg707ea08e31f44f4a81e2a7766123bad75ef5b45901a8447e5173f50746ab029d"></a><!-- doxytag: member="IPOINT_TAKEN_BRANCH" ref="gg707ea08e31f44f4a81e2a7766123bad75ef5b45901a8447e5173f50746ab029d" args="" -->IPOINT_TAKEN_BRANCH</em>&nbsp;</td><td>
Insert a call on the taken edge of branch, the side effects of the branch are visible. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g624ddd00f45938da5eb525afc5b43195"></a><!-- doxytag: member="types_vmapi.H::PIN_MEMOP_ENUM" ref="g624ddd00f45938da5eb525afc5b43195" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#g624ddd00f45938da5eb525afc5b43195">PIN_MEMOP_ENUM</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
used in the Type whose address is passed to analysis routine when IARG_MULTI_MEMORYACCESS_EA is requested 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge3eb88acf12be3a154102006b4de7e4d"></a><!-- doxytag: member="LEVEL_PINCLIENT::IARGLIST_AddArguments" ref="ge3eb88acf12be3a154102006b4de7e4d" args="(IARGLIST args,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::IARGLIST_AddArguments           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an argument to an IARGLIST.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5cbcceec6b0a3ebe21b78c85c4a8c8c9"></a><!-- doxytag: member="LEVEL_PINCLIENT::IARGLIST_Alloc" ref="g5cbcceec6b0a3ebe21b78c85c4a8c8c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> LEVEL_PINCLIENT::IARGLIST_Alloc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g392b26a0d0881f24d3abf7d4d1d8e176"></a><!-- doxytag: member="LEVEL_PINCLIENT::IARGLIST_Free" ref="g392b26a0d0881f24d3abf7d4d1d8e176" args="(IARGLIST args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::IARGLIST_Free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#gfbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jan 28 23:35:32 2018 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
